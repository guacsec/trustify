use crate::error::Error;
use crate::model::vulnerability::{VulnerabilityAdvisorySummary, VulnerabilitySummary};
use sea_orm::{prelude::*, EntityTrait, LoaderTrait, QueryFilter};
use trustify_common::db::limiter::LimiterTrait;
use trustify_common::db::Transactional;
use trustify_common::model::{Paginated, PaginatedResults};
use trustify_entity::{advisory, advisory_vulnerability, vulnerability};
use trustify_module_search::model::SearchOptions;
use trustify_module_search::query::Query;

impl super::FetchService {
    pub async fn fetch_vulnerabilities<TX: AsRef<Transactional>>(
        &self,
        search: SearchOptions,
        paginated: Paginated,
        tx: TX,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let connection = self.db.connection(&tx);

        let limiter = vulnerability::Entity::find().filtering(search)?.limiting(
            &connection,
            paginated.offset,
            paginated.limit,
        );

        let total = limiter.total().await?;

        let mut vulnerabilities = limiter.fetch().await?;

        let mut advisories = vulnerabilities
            .load_many_to_many(
                advisory::Entity,
                advisory_vulnerability::Entity,
                &self.db.connection(&tx),
            )
            .await?;

        let vulnerabilities = vulnerabilities
            .drain(..)
            .zip(advisories.drain(..))
            .map(|(vuln, mut advisories)| {
                let advisories = advisories
                    .drain(..)
                    .map(|e| VulnerabilityAdvisorySummary {
                        identifier: e.identifier,
                        sha256: e.sha256,
                        published: e.published,
                        modified: e.modified,
                        withdrawn: e.withdrawn,
                        title: e.title,
                    })
                    .collect();

                VulnerabilitySummary {
                    identifier: vuln.identifier,
                    title: vuln.title,
                    advisories,
                }
            })
            .collect();

        Ok(PaginatedResults {
            items: vulnerabilities,
            total,
        })
    }

    pub async fn fetch_vulnerability<TX: AsRef<Transactional>>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<Option<VulnerabilitySummary>, Error> {
        let result = vulnerability::Entity::find()
            .filter(vulnerability::Column::Identifier.eq(identifier))
            .find_with_related(advisory::Entity)
            .all(&self.db.connection(&tx))
            .await?;

        if result.is_empty() {
            return Ok(None);
        }

        let (vuln, advisories) = &result[0];

        let advisories = advisories
            .iter()
            .map(|e| VulnerabilityAdvisorySummary {
                identifier: e.identifier.clone(),
                sha256: e.sha256.clone(),
                published: e.published,
                modified: e.modified,
                withdrawn: e.withdrawn,
                title: e.title.clone(),
            })
            .collect();

        Ok(Some(VulnerabilitySummary {
            identifier: vuln.identifier.clone(),
            title: vuln.title.clone(),
            advisories,
        }))
    }
}
