use crate::error::Error;
use crate::model::advisory::{
    AdvisorySummary, AdvisoryVulnerabilityHead, AdvisoryVulnerabilitySummary,
};
use crate::model::vulnerability::{
    VulnerabilityAdvisoryHead, VulnerabilityAdvisorySummary, VulnerabilityDetails,
    VulnerabilityHead, VulnerabilitySummary,
};
use crate::query::{Query, SearchOptions};
use sea_orm::{prelude::*, EntityTrait, LoaderTrait, QueryFilter};
use std::collections::HashMap;
use trustify_common::advisory::{AdvisoryVulnerabilityAssertions, Assertion};
use trustify_common::db::limiter::LimiterTrait;
use trustify_common::db::Transactional;
use trustify_common::model::{Paginated, PaginatedResults};
use trustify_common::purl::Purl;
use trustify_cvss::cvss3::score::Score;
use trustify_cvss::cvss3::Cvss3Base;
use trustify_entity::{
    advisory, advisory_vulnerability, affected_package_version_range, cvss3, fixed_package_version,
    not_affected_package_version, package, package_version, package_version_range, vulnerability,
};

impl super::FetchService {
    pub(crate) async fn vulnerability_advisory_heads<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        _vulnerability_id: i32,
        advisories: &[advisory::Model],
        tx: TX,
    ) -> Result<Vec<VulnerabilityAdvisoryHead>, Error> {
        Ok(self
            .advisory_heads(advisories, &tx)
            .await?
            .drain(..)
            .map(|head| VulnerabilityAdvisoryHead { head })
            .collect())
    }

    pub(crate) async fn vulnerability_advisory_head<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        vulnerability_id: i32,
        advisory: &advisory::Model,
        tx: TX,
    ) -> Result<Option<VulnerabilityAdvisoryHead>, Error> {
        Ok(self
            .vulnerability_advisory_heads(vulnerability_id, &[advisory.clone()], &tx)
            .await?
            .first()
            .cloned())
    }

    pub(crate) async fn vulnerability_advisory_summaries<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        vulnerability_id: i32,
        advisories: &Vec<advisory::Model>,
        tx: TX,
    ) -> Result<Vec<VulnerabilityAdvisorySummary>, Error> {
        let mut summaries = Vec::new();

        let mut fixed = advisories
            .load_many(
                fixed_package_version::Entity::find()
                    .filter(fixed_package_version::Column::VulnerabilityId.eq(vulnerability_id)),
                &self.db.connection(&tx),
            )
            .await?;

        let mut affected = advisories
            .load_many(
                affected_package_version_range::Entity::find().filter(
                    affected_package_version_range::Column::VulnerabilityId.eq(vulnerability_id),
                ),
                &self.db.connection(&tx),
            )
            .await?;

        let mut not_affected = advisories
            .load_many(
                not_affected_package_version::Entity::find().filter(
                    not_affected_package_version::Column::VulnerabilityId.eq(vulnerability_id),
                ),
                &self.db.connection(&tx),
            )
            .await?;

        let mut cvss3s = advisories
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::VulnerabilityId.eq(vulnerability_id)),
                &self.db.connection(&tx),
            )
            .await?;

        for ((((advisory, mut fixed), mut affected), mut not_affected), mut cvss3) in advisories
            .iter()
            .zip(fixed.drain(..))
            .zip(affected.drain(..))
            .zip(not_affected.drain(..))
            .zip(cvss3s.drain(..))
        {
            let mut assertions = HashMap::new();

            'fixed: {
                let mut package_versions = fixed
                    .load_one(package_version::Entity, &self.db.connection(&tx))
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_versions
                    .load_one(package::Entity, &self.db.connection(&tx))
                    .await?;

                packages.drain(..).zip(package_versions.drain(..)).for_each(
                    |(package, version)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::Fixed {
                                version: version.version,
                            })
                        }
                    },
                );
            }

            'affected: {
                let mut package_version_ranges = affected
                    .load_one(package_version_range::Entity, &self.db.connection(&tx))
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_version_ranges
                    .load_one(package::Entity, &self.db.connection(&tx))
                    .await?
                    .drain(..)
                    .collect::<Vec<_>>();

                packages
                    .drain(..)
                    .zip(package_version_ranges.drain(..))
                    .for_each(|(package, version_range)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::Affected {
                                start_version: version_range.start,
                                end_version: version_range.end,
                            })
                        }
                    });
            }

            'not_affected: {
                let mut package_versions = not_affected
                    .load_one(package_version::Entity, &self.db.connection(&tx))
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_versions
                    .load_one(package::Entity, &self.db.connection(&tx))
                    .await?
                    .drain(..)
                    .collect::<Vec<_>>();

                packages.drain(..).zip(package_versions.drain(..)).for_each(
                    |(package, version)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::NotAffected {
                                version: version.version,
                            })
                        }
                    },
                );

                let cvss3_scores = cvss3
                    .drain(..)
                    .map(|e| Cvss3Base::from(e).to_string())
                    .collect();

                if let Some(head) = self
                    .vulnerability_advisory_head(vulnerability_id, advisory, &tx)
                    .await?
                {
                    summaries.push(VulnerabilityAdvisorySummary {
                        head,
                        cvss3_scores,
                        assertions: Default::default(),
                    });
                }
            }
        }

        Ok(summaries)
    }

    pub(crate) async fn vulnerability_summaries<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        vulnerabilities: &Vec<vulnerability::Model>,
        tx: TX,
    ) -> Result<Vec<VulnerabilitySummary>, Error> {
        let advisories = vulnerabilities
            .load_many(advisory::Entity::find(), &self.db.connection(&tx))
            .await?;

        let mut summaries = Vec::new();

        for (vuln, advisories) in vulnerabilities.iter().zip(advisories.iter()) {
            summaries.push(VulnerabilitySummary {
                head: VulnerabilityHead {
                    identifier: vuln.identifier.clone(),
                    title: vuln.title.clone(),
                },
                advisories: self
                    .vulnerability_advisory_heads(vuln.id, advisories, &tx)
                    .await?,
            });
        }

        Ok(summaries)
    }

    pub(crate) async fn vulnerability_heads<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        vulnerabilities: &[vulnerability::Model],
        tx: TX,
    ) -> Result<Vec<VulnerabilityHead>, Error> {
        Ok(vulnerabilities
            .iter()
            .map(|vuln| VulnerabilityHead {
                identifier: vuln.identifier.clone(),
                title: vuln.title.clone(),
            })
            .collect())
    }

    pub(crate) async fn vulnerability_head<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        vulnerability: &vulnerability::Model,
        tx: TX,
    ) -> Result<Option<VulnerabilityHead>, Error> {
        Ok(self
            .vulnerability_heads(&[vulnerability.clone()], &tx)
            .await?
            .first()
            .cloned())
    }

    pub async fn vulnerability_details<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        vulnerabilities: &Vec<vulnerability::Model>,
        tx: TX,
    ) -> Result<Vec<VulnerabilityDetails>, Error> {
        let advisories = vulnerabilities
            .load_many(advisory::Entity::find(), &self.db.connection(&tx))
            .await?;

        let mut details = Vec::new();

        for (vuln, advisories) in vulnerabilities.iter().zip(advisories.iter()) {
            if let Some(head) = self.vulnerability_head(vuln, &tx).await? {
                details.push(VulnerabilityDetails {
                    head,
                    advisories: self
                        .vulnerability_advisory_summaries(vuln.id, advisories, &tx)
                        .await?,
                })
            }
        }

        Ok(details)
        /*
        let mut fixed = vulnerabilities
            .load_many(fixed_package_version::Entity, &self.db.connection(&tx))
            .await?;

        let mut affected = vulnerabilities
            .load_many(
                affected_package_version_range::Entity,
                &self.db.connection(&tx),
            )
            .await?;

        let mut not_affected = vulnerabilities
            .load_many(
                not_affected_package_version::Entity,
                &self.db.connection(&tx),
            )
            .await?;

        let mut cvss3s = vulnerabilities
            .load_many(cvss3::Entity::find(), &self.db.connection(&tx))
            .await?;

         */

        /*
        for ((((vuln, mut fixed), mut affected), mut not_affected), mut cvss3) in vulnerabilities
            .iter()
            .zip(fixed.drain(..))
            .zip(affected.drain(..))
            .zip(not_affected.drain(..))
            .zip(cvss3s.drain(..))
        {
            let mut assertions = HashMap::new();

            'fixed: {
                let mut package_versions = fixed
                    .load_one(package_version::Entity, &self.db.connection(&tx))
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_versions
                    .load_one(package::Entity, &self.db.connection(&tx))
                    .await?;

                packages.drain(..).zip(package_versions.drain(..)).for_each(
                    |(package, version)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::Fixed {
                                version: version.version,
                            })
                        }
                    },
                );
            }

            'affected: {
                let mut package_version_ranges = affected
                    .load_one(package_version_range::Entity, &self.db.connection(&tx))
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_version_ranges
                    .load_one(package::Entity, &self.db.connection(&tx))
                    .await?
                    .drain(..)
                    .collect::<Vec<_>>();

                packages
                    .drain(..)
                    .zip(package_version_ranges.drain(..))
                    .for_each(|(package, version_range)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::Affected {
                                start_version: version_range.start,
                                end_version: version_range.end,
                            })
                        }
                    });
            }

            'not_affected: {
                let mut package_versions = not_affected
                    .load_one(package_version::Entity, &self.db.connection(&tx))
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_versions
                    .load_one(package::Entity, &self.db.connection(&tx))
                    .await?
                    .drain(..)
                    .collect::<Vec<_>>();

                packages.drain(..).zip(package_versions.drain(..)).for_each(
                    |(package, version)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::NotAffected {
                                version: version.version,
                            })
                        }
                    },
                );

                let cvss3_scores = cvss3
                    .drain(..)
                    .map(|e| Cvss3Base::from(e).to_string())
                    .collect();

                if let Some(head) = self.vulnerability_head(vuln, &tx).await? {
                    details.push(VulnerabilityDetails {
                        head,
                        cvss3_scores,
                        assertions: Default::default(),
                    });
                }
            }
        }

        Ok(details)

         */
    }

    pub async fn fetch_vulnerabilities<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        search: SearchOptions,
        paginated: Paginated,
        tx: TX,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let connection = self.db.connection(&tx);

        let limiter = vulnerability::Entity::find().filtering(search)?.limiting(
            &connection,
            paginated.offset,
            paginated.limit,
        );

        let total = limiter.total().await?;

        let mut vulnerabilities = limiter.fetch().await?;

        let mut advisories = vulnerabilities
            .load_many_to_many(
                advisory::Entity,
                advisory_vulnerability::Entity,
                &self.db.connection(&tx),
            )
            .await?;

        let mut items = Vec::new();

        for (vuln, advisories) in vulnerabilities.drain(..).zip(advisories) {
            items.push(VulnerabilitySummary {
                head: VulnerabilityHead {
                    identifier: vuln.identifier,
                    title: vuln.title,
                },
                advisories: self
                    .vulnerability_advisory_heads(vuln.id, &advisories, &tx)
                    .await?,
            });
        }

        Ok(PaginatedResults { items, total })
    }

    pub async fn fetch_vulnerability<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        let result = vulnerability::Entity::find()
            .filter(vulnerability::Column::Identifier.eq(identifier))
            .find_with_related(advisory::Entity)
            .all(&self.db.connection(&tx))
            .await?;

        if result.is_empty() {
            return Ok(None);
        }

        let (vuln, advisories) = &result[0];

        let advisories = self
            .vulnerability_advisory_summaries(vuln.id, advisories, tx)
            .await?;

        Ok(Some(VulnerabilityDetails {
            head: VulnerabilityHead {
                identifier: vuln.identifier.clone(),
                title: vuln.title.clone(),
            },
            advisories,
        }))
    }
}
