use crate::service::VulnerabilityService;
use actix_web::{get, web, HttpResponse, Responder};
use trustify_common::db::query::SearchOptions;
use trustify_common::db::{Database, Transactional};
use trustify_common::model::Paginated;
use utoipa::OpenApi;

pub fn configure(config: &mut web::ServiceConfig, db: Database) {
    let service = VulnerabilityService::new(db);
    config.app_data(web::Data::new(service)).service(
        web::scope("/api/v1/vulnerability")
            .service(all)
            .service(get),
    );
}

#[derive(OpenApi)]
#[openapi(
    paths(all, get),
    components(schemas(
        trustify_model::vulnerability::VulnerabilityHead,
        trustify_model::vulnerability::VulnerabilitySummary,
        trustify_model::vulnerability::VulnerabilityDetails,
        trustify_model::vulnerability::VulnerabilityAdvisoryHead,
        trustify_model::vulnerability::VulnerabilityAdvisorySummary,
        trustify_model::vulnerability::PaginatedVulnerabilitySummary,
        trustify_common::advisory::AdvisoryVulnerabilityAssertions,
        trustify_common::advisory::Assertion,
        trustify_common::purl::Purl,
    )),
    tags()
)]
pub struct ApiDoc;

#[utoipa::path(
    tag = "vulnerability",
    params(
        SearchOptions,
        Paginated,
    ),
    responses(
        (status = 200, description = "Matching vulnerabilities", body = PaginatedVulnerabilitySummary),
    ),
)]
#[get("")]
pub async fn all(
    state: web::Data<VulnerabilityService>,
    web::Query(search): web::Query<SearchOptions>,
    web::Query(paginated): web::Query<Paginated>,
) -> actix_web::Result<impl Responder> {
    Ok(HttpResponse::Ok().json(
        state
            .fetch_vulnerabilities(search, paginated, Transactional::None)
            .await?,
    ))
}

#[utoipa::path(
    context_path = "/api/v1/vulnerability",
    tag = "vulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Specified vulnerability", body = VulnerabilityDetails),
        (status = 404, description = "Specified vulnerability not found"),
    ),
)]
#[get("{id}")]
pub async fn get(
    state: web::Data<VulnerabilityService>,
    id: web::Path<String>,
) -> actix_web::Result<impl Responder> {
    let vuln = state.fetch_vulnerability(&id, Transactional::None).await?;
    if let Some(vuln) = vuln {
        Ok(HttpResponse::Ok().json(vuln))
    } else {
        Ok(HttpResponse::NotFound().finish())
    }
}

#[utoipa::path(
    context_path = "/api/v1/vulnerability",
    tag = "vulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Affected products"),
    ),
)]
#[get("{id}/affected/products")]
pub async fn affected_products(
    //state: web::Data<Graph>,
    _id: web::Path<String>,
) -> actix_web::Result<impl Responder> {
    Ok(HttpResponse::Ok().finish())
}

#[cfg(test)]
mod test;
