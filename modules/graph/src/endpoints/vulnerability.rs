use crate::endpoints::Error;
use crate::graph::Graph;
use crate::model::vulnerability::Vulnerability;
use actix_web::{get, web, HttpResponse, Responder};
use trustify_common::model::{Paginated, PaginatedResults};
use trustify_entity::vulnerability::Model;
use trustify_module_search::model::SearchOptions;

#[utoipa::path(
    context_path = "/api/v1/vulnerability",
    tag = "vulnerability",
    params(
        SearchOptions,
        Paginated,
    ),
    responses(
        (status = 200, description = "Matching vulnerabilities"),
    ),
)]
#[get("")]
pub async fn all(
    state: web::Data<Graph>,
    web::Query(search): web::Query<SearchOptions>,
    web::Query(paginated): web::Query<Paginated>,
) -> actix_web::Result<impl Responder> {
    let results = state
        .vulnerabilities(search, paginated, ())
        .await
        .map_err(Error::System)?
        .map(|e| Vulnerability::from(e.vulnerability));

    Ok(HttpResponse::Ok().json(results))
}

#[utoipa::path(
    context_path = "/api/v1/vulnerability",
    tag = "vulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Advisories related to the vulnerability"),
    ),
)]
#[get("/vulnerability/{id}/advisories")]
pub async fn advisories(state: web::Data<Graph>) -> actix_web::Result<impl Responder> {
    Ok(HttpResponse::Ok().finish())
}

#[utoipa::path(
    context_path = "/api/v1/vulnerability",
    tag = "vulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Affected packages"),
    ),
)]
#[get("/vulnerability/{id}/affected/packages")]
pub async fn affected_packages(
    state: web::Data<Graph>,
    id: web::Path<String>,
) -> actix_web::Result<impl Responder> {
    Ok(HttpResponse::Ok().finish())
}

#[utoipa::path(
    context_path = "/api/v1/vulnerability",
    tag = "vulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Affected products"),
    ),
)]
#[get("/vulnerability/{id}/affected/products")]
pub async fn affected_products(
    state: web::Data<Graph>,
    id: web::Path<String>,
) -> actix_web::Result<impl Responder> {
    Ok(HttpResponse::Ok().finish())
}

#[cfg(test)]
mod tests {
    use crate::graph::Graph;
    use actix_web::test::TestRequest;
    use actix_web::web::Data;
    use actix_web::{web, App};
    use std::sync::Arc;
    use trustify_common::db::Database;
    use trustify_common::model::PaginatedResults;
    use trustify_entity::vulnerability;

    use crate::model::vulnerability::Vulnerability;
    use test_log::test;

    #[test(actix_web::test)]
    async fn all_vulnerabilities() -> Result<(), anyhow::Error> {
        let db = Database::for_test("api_all_vulnerabilities").await?;
        let graph = Arc::new(Graph::new(db));

        let vuln = graph.ingest_vulnerability("CVE-111", ()).await?;

        vuln.set_title(Some("Bob's CVE".to_string()), ()).await?;

        let vuln = graph.ingest_vulnerability("CVE-222", ()).await?;

        vuln.set_title(Some("Jim's CVE".to_string()), ()).await?;

        let vuln = graph.ingest_vulnerability("CVE-333", ()).await?;

        vuln.set_title(Some("Jenß CVE".to_string()), ()).await?;

        let app = actix_web::test::init_service(
            App::new()
                .app_data(web::Data::from(graph.clone()))
                .configure(crate::endpoints::configure),
        )
        .await;

        let uri = "/api/v1/vulnerability";

        let request = TestRequest::get().uri(uri).to_request();

        let response: PaginatedResults<Vulnerability> =
            actix_web::test::call_and_read_body_json(&app, request).await;

        assert_eq!(3, response.items.len());

        Ok(())
    }

    #[test(actix_web::test)]
    async fn all_vulnerabilities_paginated() -> Result<(), anyhow::Error> {
        let db = Database::for_test("api_all_vulnerabilities_paginated").await?;
        let graph = Arc::new(Graph::new(db));

        let vuln = graph.ingest_vulnerability("CVE-111", ()).await?;

        vuln.set_title(Some("Bob's CVE".to_string()), ()).await?;

        let vuln = graph.ingest_vulnerability("CVE-222", ()).await?;

        vuln.set_title(Some("Jim's CVE".to_string()), ()).await?;

        let vuln = graph.ingest_vulnerability("CVE-333", ()).await?;

        vuln.set_title(Some("Jenß CVE".to_string()), ()).await?;

        let app = actix_web::test::init_service(
            App::new()
                .app_data(web::Data::from(graph.clone()))
                .configure(crate::endpoints::configure),
        )
        .await;

        let uri = "/api/v1/vulnerability?limit=2";

        let request = TestRequest::get().uri(uri).to_request();

        let response: PaginatedResults<Vulnerability> =
            actix_web::test::call_and_read_body_json(&app, request).await;

        assert_eq!(2, response.items.len());

        Ok(())
    }

    #[test(actix_web::test)]
    async fn all_vulnerabilities_filtered() -> Result<(), anyhow::Error> {
        let db = Database::for_test("api_all_vulnerabilities_filtered").await?;
        let graph = Arc::new(Graph::new(db));

        let vuln = graph.ingest_vulnerability("CVE-111", ()).await?;

        vuln.set_title(Some("Bob's CVE".to_string()), ()).await?;

        let vuln = graph.ingest_vulnerability("CVE-222", ()).await?;

        vuln.set_title(Some("Jim's CVE".to_string()), ()).await?;

        let vuln = graph.ingest_vulnerability("CVE-333", ()).await?;

        vuln.set_title(Some("Jenß CVE".to_string()), ()).await?;

        let app = actix_web::test::init_service(
            App::new()
                .app_data(web::Data::from(graph.clone()))
                .configure(crate::endpoints::configure),
        )
        .await;

        let uri = "/api/v1/vulnerability?q=Bob";

        let request = TestRequest::get().uri(uri).to_request();

        let response: PaginatedResults<Vulnerability> =
            actix_web::test::call_and_read_body_json(&app, request).await;

        assert_eq!(1, response.items.len());

        Ok(())
    }
}
