use crate::graph::advisory::affected_package_version_range::AffectedPackageVersionRangeContext;
use crate::graph::advisory::fixed_package_version::FixedPackageVersionContext;
use crate::graph::advisory::not_affected_package_version::NotAffectedPackageVersionContext;
use crate::graph::advisory::AdvisoryContext;
use crate::graph::error::Error;
use sea_orm::{ActiveModelTrait, ColumnTrait, EntityTrait, QueryFilter, Set};
use trustify_common::db::Transactional;
use trustify_common::purl::Purl;
use trustify_cvss::cvss3::Cvss3Base;
use trustify_entity as entity;

#[derive(Clone, Debug)]
pub struct AdvisoryVulnerabilityContext<'g> {
    pub advisory: AdvisoryContext<'g>,
    pub advisory_vulnerability: entity::advisory_vulnerability::Model,
}

impl<'g> From<(&AdvisoryContext<'g>, entity::advisory_vulnerability::Model)>
    for AdvisoryVulnerabilityContext<'g>
{
    fn from(
        (advisory, vulnerability): (&AdvisoryContext<'g>, entity::advisory_vulnerability::Model),
    ) -> Self {
        Self {
            advisory: advisory.clone(),
            advisory_vulnerability: vulnerability,
        }
    }
}

impl<'g> AdvisoryVulnerabilityContext<'g> {
    pub async fn get_fixed_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<Option<FixedPackageVersionContext>, Error> {
        if let Some(package_version) = self.advisory.graph.get_package_version(purl, &tx).await? {
            Ok(entity::fixed_package_version::Entity::find()
                .filter(
                    entity::fixed_package_version::Column::AdvisoryId.eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::fixed_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|affected| (self, affected).into()))
        } else {
            Ok(None)
        }
    }

    pub async fn get_not_affected_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<Option<NotAffectedPackageVersionContext>, Error> {
        if let Some(package_version) = self.advisory.graph.get_package_version(purl, &tx).await? {
            Ok(entity::not_affected_package_version::Entity::find()
                .filter(
                    entity::not_affected_package_version::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::not_affected_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|not_affected_package_version| (self, not_affected_package_version).into()))
        } else {
            Ok(None)
        }
    }

    pub async fn get_affected_package_range<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        start: &str,
        end: &str,
        tx: TX,
    ) -> Result<Option<AffectedPackageVersionRangeContext>, Error> {
        if let Some(package_version_range) = self
            .advisory
            .graph
            .get_package_version_range(purl.clone(), start, end, &tx)
            .await?
        {
            Ok(entity::affected_package_version_range::Entity::find()
                .filter(
                    entity::affected_package_version_range::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::affected_package_version_range::Column::PackageVersionRangeId
                        .eq(package_version_range.package_version_range.id),
                )
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|affected| (self, affected).into()))
        } else {
            Ok(None)
        }
    }

    pub async fn ingest_not_affected_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<NotAffectedPackageVersionContext, Error> {
        if let Some(found) = self
            .get_not_affected_package_version(purl.clone(), &tx)
            .await?
        {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .graph
            .ingest_package_version(purl, &tx)
            .await?;

        let entity = entity::not_affected_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok((
            self,
            entity.insert(&self.advisory.graph.connection(&tx)).await?,
        )
            .into())
    }

    pub async fn ingest_fixed_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<FixedPackageVersionContext, Error> {
        if let Some(found) = self.get_fixed_package_version(purl.clone(), &tx).await? {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .graph
            .ingest_package_version(purl, &tx)
            .await?;

        let entity = entity::fixed_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok((
            self,
            entity.insert(&self.advisory.graph.connection(&tx)).await?,
        )
            .into())
    }

    pub async fn ingest_affected_package_range<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        start: &str,
        end: &str,
        tx: TX,
    ) -> Result<AffectedPackageVersionRangeContext, Error> {
        if let Some(found) = self
            .get_affected_package_range(purl.clone(), start, end, &tx)
            .await?
        {
            return Ok(found);
        }

        let package_version_range = self
            .advisory
            .graph
            .ingest_package_version_range(purl, start, end, &tx)
            .await?;

        let entity = entity::affected_package_version_range::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_range_id: Set(package_version_range.package_version_range.id),
        };

        Ok((
            self,
            entity.insert(&self.advisory.graph.connection(&tx)).await?,
        )
            .into())
    }

    pub async fn cvss3_scores<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<Cvss3Base>, Error> {
        Ok(entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.advisory_id))
            .filter(
                entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.vulnerability_id),
            )
            .all(&self.advisory.graph.connection(&tx))
            .await?
            .drain(..)
            .map(|e| e.into())
            .collect())
    }

    pub async fn get_cvss3_score<TX: AsRef<Transactional>>(
        &self,
        minor_version: u8,
        tx: TX,
    ) -> Result<Option<Cvss3Base>, Error> {
        Ok(entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.advisory_id))
            .filter(
                entity::cvss3::Column::VulnerabilityId
                    .eq(self.advisory_vulnerability.vulnerability_id),
            )
            .filter(entity::cvss3::Column::MinorVersion.eq(minor_version as i32))
            .one(&self.advisory.graph.connection(&tx))
            .await?
            .map(|cvss| cvss.into()))
    }

    pub async fn ingest_cvss3_score<TX: AsRef<Transactional>>(
        &self,
        cvss3: Cvss3Base,
        tx: TX,
    ) -> Result<Cvss3Base, Error> {
        if let Some(found) = self.get_cvss3_score(cvss3.minor_version, &tx).await? {
            return Ok(found);
        }

        let model = entity::cvss3::ActiveModel {
            advisory_id: Set(self.advisory_vulnerability.advisory_id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id),
            minor_version: sea_orm::ActiveValue::Set(cvss3.minor_version as i32),
            av: Set(cvss3.av.into()),
            ac: Set(cvss3.ac.into()),
            pr: Set(cvss3.pr.into()),
            ui: Set(cvss3.ui.into()),
            s: Set(cvss3.s.into()),
            c: Set(cvss3.c.into()),
            i: Set(cvss3.i.into()),
            a: Set(cvss3.a.into()),
        };

        Ok(model.insert(&self.advisory.graph.db).await?.into())
    }
}
