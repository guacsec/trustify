use crate::graph::advisory::affected_package_version_range::AffectedPackageVersionRangeContext;
use crate::graph::advisory::fixed_package_version::FixedPackageVersionContext;
use crate::graph::advisory::not_affected_package_version::NotAffectedPackageVersionContext;
use crate::graph::advisory::AdvisoryContext;
use crate::graph::error::Error;
use crate::graph::vulnerability::VulnerabilityContext;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, EntityTrait, FromQueryResult, QueryFilter, QuerySelect,
    RelationTrait, Set,
};
use sea_query::JoinType;
use std::collections::HashMap;
use trustify_common::advisory::{AdvisoryVulnerabilityAssertions, Assertion};
use trustify_common::db::Transactional;
use trustify_common::purl::Purl;
use trustify_cvss::cvss3::Cvss3Base;
use trustify_entity as entity;
use trustify_entity::vulnerability;

#[derive(Clone, Debug)]
pub struct AdvisoryVulnerabilityContext<'g> {
    pub advisory: AdvisoryContext<'g>,
    pub advisory_vulnerability: entity::advisory_vulnerability::Model,
}

impl<'g> From<(&AdvisoryContext<'g>, entity::advisory_vulnerability::Model)>
    for AdvisoryVulnerabilityContext<'g>
{
    fn from(
        (advisory, vulnerability): (&AdvisoryContext<'g>, entity::advisory_vulnerability::Model),
    ) -> Self {
        Self {
            advisory: advisory.clone(),
            advisory_vulnerability: vulnerability,
        }
    }
}

impl<'g> AdvisoryVulnerabilityContext<'g> {
    pub async fn vulnerability<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(
            vulnerability::Entity::find_by_id(self.advisory_vulnerability.vulnerability_id)
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|vuln| VulnerabilityContext::new(self.advisory.graph, vuln)),
        )
    }

    pub async fn get_fixed_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<Option<FixedPackageVersionContext>, Error> {
        if let Some(package_version) = self.advisory.graph.get_package_version(purl, &tx).await? {
            Ok(entity::fixed_package_version::Entity::find()
                .filter(
                    entity::fixed_package_version::Column::AdvisoryId.eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::fixed_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|affected| FixedPackageVersionContext::new(self, affected)))
        } else {
            Ok(None)
        }
    }

    pub async fn get_not_affected_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<Option<NotAffectedPackageVersionContext>, Error> {
        if let Some(package_version) = self.advisory.graph.get_package_version(purl, &tx).await? {
            Ok(entity::not_affected_package_version::Entity::find()
                .filter(
                    entity::not_affected_package_version::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::not_affected_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|not_affected_package_version| {
                    NotAffectedPackageVersionContext::new(self, not_affected_package_version)
                }))
        } else {
            Ok(None)
        }
    }

    pub async fn get_affected_package_range<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        start: &str,
        end: &str,
        tx: TX,
    ) -> Result<Option<AffectedPackageVersionRangeContext>, Error> {
        if let Some(package_version_range) = self
            .advisory
            .graph
            .get_package_version_range(purl.clone(), start, end, &tx)
            .await?
        {
            Ok(entity::affected_package_version_range::Entity::find()
                .filter(
                    entity::affected_package_version_range::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::affected_package_version_range::Column::PackageVersionRangeId
                        .eq(package_version_range.package_version_range.id),
                )
                .one(&self.advisory.graph.connection(&tx))
                .await?
                .map(|affected| AffectedPackageVersionRangeContext::new(self, affected)))
        } else {
            Ok(None)
        }
    }

    pub async fn ingest_not_affected_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<NotAffectedPackageVersionContext, Error> {
        if let Some(found) = self
            .get_not_affected_package_version(purl.clone(), &tx)
            .await?
        {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .graph
            .ingest_package_version(purl, &tx)
            .await?;

        let entity = entity::not_affected_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok(NotAffectedPackageVersionContext::new(
            self,
            entity.insert(&self.advisory.graph.connection(&tx)).await?,
        ))
    }

    pub async fn ingest_fixed_package_version<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        tx: TX,
    ) -> Result<FixedPackageVersionContext, Error> {
        if let Some(found) = self.get_fixed_package_version(purl.clone(), &tx).await? {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .graph
            .ingest_package_version(purl, &tx)
            .await?;

        let entity = entity::fixed_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok(FixedPackageVersionContext::new(
            self,
            entity.insert(&self.advisory.graph.connection(&tx)).await?,
        ))
    }

    pub async fn ingest_affected_package_range<TX: AsRef<Transactional>>(
        &self,
        purl: Purl,
        start: &str,
        end: &str,
        tx: TX,
    ) -> Result<AffectedPackageVersionRangeContext, Error> {
        if let Some(found) = self
            .get_affected_package_range(purl.clone(), start, end, &tx)
            .await?
        {
            return Ok(found);
        }

        let package_version_range = self
            .advisory
            .graph
            .ingest_package_version_range(purl, start, end, &tx)
            .await?;

        let entity = entity::affected_package_version_range::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_range_id: Set(package_version_range.package_version_range.id),
        };

        Ok(AffectedPackageVersionRangeContext::new(
            self,
            entity.insert(&self.advisory.graph.connection(&tx)).await?,
        ))
    }

    pub async fn cvss3_scores<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<Cvss3Base>, Error> {
        Ok(entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.advisory_id))
            .filter(
                entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.vulnerability_id),
            )
            .all(&self.advisory.graph.connection(&tx))
            .await?
            .drain(..)
            .map(|e| e.into())
            .collect())
    }

    pub async fn get_cvss3_score<TX: AsRef<Transactional>>(
        &self,
        minor_version: u8,
        tx: TX,
    ) -> Result<Option<Cvss3Base>, Error> {
        Ok(entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(self.advisory_vulnerability.advisory_id))
            .filter(
                entity::cvss3::Column::VulnerabilityId
                    .eq(self.advisory_vulnerability.vulnerability_id),
            )
            .filter(entity::cvss3::Column::MinorVersion.eq(minor_version as i32))
            .one(&self.advisory.graph.connection(&tx))
            .await?
            .map(|cvss| cvss.into()))
    }

    pub async fn ingest_cvss3_score<TX: AsRef<Transactional>>(
        &self,
        cvss3: Cvss3Base,
        tx: TX,
    ) -> Result<Cvss3Base, Error> {
        if let Some(found) = self.get_cvss3_score(cvss3.minor_version, &tx).await? {
            return Ok(found);
        }

        let model = entity::cvss3::ActiveModel {
            advisory_id: Set(self.advisory_vulnerability.advisory_id),
            vulnerability_id: Set(self.advisory_vulnerability.vulnerability_id),
            minor_version: sea_orm::ActiveValue::Set(cvss3.minor_version as i32),
            av: Set(cvss3.av.into()),
            ac: Set(cvss3.ac.into()),
            pr: Set(cvss3.pr.into()),
            ui: Set(cvss3.ui.into()),
            s: Set(cvss3.s.into()),
            c: Set(cvss3.c.into()),
            i: Set(cvss3.i.into()),
            a: Set(cvss3.a.into()),
        };

        Ok(model.insert(&self.advisory.graph.db).await?.into())
    }

    pub async fn vulnerability_assertions<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<AdvisoryVulnerabilityAssertions, Error> {
        let affected = self.affected_assertions(&tx).await?;
        let not_affected = self.not_affected_assertions(&tx).await?;
        let fixed = self.fixed_assertions(&tx).await?;

        let mut merged = affected.assertions.clone();

        for (package_key, assertions) in not_affected.assertions {
            merged
                .entry(package_key)
                .or_insert(Vec::default())
                .extend_from_slice(&assertions)
        }

        for (package_key, assertions) in fixed.assertions {
            merged
                .entry(package_key)
                .or_insert(Vec::default())
                .extend_from_slice(&assertions)
        }

        Ok(AdvisoryVulnerabilityAssertions { assertions: merged })
    }

    pub async fn affected_assertions<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<AdvisoryVulnerabilityAssertions, Error> {
        #[derive(FromQueryResult, Debug)]
        struct AffectedVersion {
            ty: String,
            namespace: Option<String>,
            name: String,
            start: String,
            end: String,
            vulnerability: String,
            identifier: String,
            location: String,
            sha256: String,
        }

        let mut affected_version_ranges = entity::affected_package_version_range::Entity::find()
            .column_as(entity::package::Column::Type, "ty")
            .column_as(entity::package::Column::Namespace, "namespace")
            .column_as(entity::package::Column::Name, "name")
            .column_as(entity::package_version_range::Column::Start, "start")
            .column_as(entity::package_version_range::Column::End, "end")
            .column_as(entity::vulnerability::Column::Identifier, "vulnerability")
            .column_as(entity::advisory::Column::Identifier, "identifier")
            .column_as(entity::advisory::Column::Location, "location")
            .column_as(entity::advisory::Column::Sha256, "sha256")
            .join(
                JoinType::Join,
                entity::affected_package_version_range::Relation::PackageVersionRange.def(),
            )
            .join(
                JoinType::Join,
                entity::affected_package_version_range::Relation::Advisory.def(),
            )
            .join(
                JoinType::Join,
                entity::package_version_range::Relation::Package.def(),
            )
            .join(
                JoinType::Join,
                entity::advisory_vulnerability::Relation::Advisory
                    .def()
                    .rev(),
            )
            .join(
                JoinType::Join,
                entity::advisory_vulnerability::Relation::Vulnerability.def(),
            )
            .filter(
                entity::affected_package_version_range::Column::AdvisoryId
                    .eq(self.advisory.advisory.id),
            )
            .into_model::<AffectedVersion>()
            .all(&self.advisory.graph.connection(&tx))
            .await?;

        let mut assertions = HashMap::new();

        for each in affected_version_ranges {
            let package_key = Purl {
                ty: each.ty,
                namespace: each.namespace,
                name: each.name,
                version: None,
                qualifiers: Default::default(),
            }
            .to_string();

            let mut package_assertions = assertions.entry(package_key.clone()).or_insert(vec![]);

            package_assertions.push(Assertion::Affected {
                start_version: each.start,
                end_version: each.end,
            });
        }

        Ok(AdvisoryVulnerabilityAssertions { assertions })
    }

    pub async fn not_affected_assertions<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<AdvisoryVulnerabilityAssertions, Error> {
        #[derive(FromQueryResult, Debug)]
        struct NotAffectedVersion {
            ty: String,
            namespace: Option<String>,
            name: String,
            version: String,
            vulnerability: String,
            identifier: String,
            location: String,
            sha256: String,
        }

        let mut not_affected_versions = entity::not_affected_package_version::Entity::find()
            .column_as(entity::package::Column::Type, "ty")
            .column_as(entity::package::Column::Namespace, "namespace")
            .column_as(entity::package::Column::Name, "name")
            .column_as(entity::package_version::Column::Version, "version")
            .column_as(entity::vulnerability::Column::Identifier, "vulnerability")
            .column_as(entity::advisory::Column::Identifier, "identifier")
            .column_as(entity::advisory::Column::Location, "location")
            .column_as(entity::advisory::Column::Sha256, "sha256")
            .join(
                JoinType::Join,
                entity::not_affected_package_version::Relation::PackageVersion.def(),
            )
            .join(
                JoinType::Join,
                entity::not_affected_package_version::Relation::Advisory.def(),
            )
            .join(
                JoinType::Join,
                entity::package_version::Relation::Package.def(),
            )
            .join(
                JoinType::Join,
                entity::advisory_vulnerability::Relation::Advisory
                    .def()
                    .rev(),
            )
            .join(
                JoinType::Join,
                entity::advisory_vulnerability::Relation::Vulnerability.def(),
            )
            .filter(
                entity::not_affected_package_version::Column::AdvisoryId
                    .eq(self.advisory.advisory.id),
            )
            .into_model::<NotAffectedVersion>()
            .all(&self.advisory.graph.connection(&tx))
            .await?;

        let mut assertions = HashMap::new();

        for each in not_affected_versions {
            let package_key = Purl {
                ty: each.ty,
                namespace: each.namespace,
                name: each.name,
                version: None,
                qualifiers: Default::default(),
            }
            .to_string();

            let mut package_assertions = assertions.entry(package_key.clone()).or_insert(vec![]);

            package_assertions.push(Assertion::NotAffected {
                version: each.version,
            });
        }

        Ok(AdvisoryVulnerabilityAssertions { assertions })
    }

    pub async fn fixed_assertions<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<AdvisoryVulnerabilityAssertions, Error> {
        #[derive(FromQueryResult, Debug)]
        struct FixedVersion {
            ty: String,
            namespace: Option<String>,
            name: String,
            version: String,
            vulnerability: String,
            identifier: String,
            location: String,
            sha256: String,
        }

        let mut fixed_versions = entity::fixed_package_version::Entity::find()
            .column_as(entity::package::Column::Type, "ty")
            .column_as(entity::package::Column::Namespace, "namespace")
            .column_as(entity::package::Column::Name, "name")
            .column_as(entity::package_version::Column::Version, "version")
            .column_as(entity::vulnerability::Column::Identifier, "vulnerability")
            .column_as(entity::advisory::Column::Identifier, "identifier")
            .column_as(entity::advisory::Column::Location, "location")
            .column_as(entity::advisory::Column::Sha256, "sha256")
            .join(
                JoinType::Join,
                entity::fixed_package_version::Relation::PackageVersion.def(),
            )
            .join(
                JoinType::Join,
                entity::fixed_package_version::Relation::Advisory.def(),
            )
            .join(
                JoinType::Join,
                entity::package_version::Relation::Package.def(),
            )
            .join(
                JoinType::Join,
                entity::advisory_vulnerability::Relation::Advisory
                    .def()
                    .rev(),
            )
            .join(
                JoinType::Join,
                entity::advisory_vulnerability::Relation::Vulnerability.def(),
            )
            .filter(entity::fixed_package_version::Column::AdvisoryId.eq(self.advisory.advisory.id))
            .into_model::<FixedVersion>()
            .all(&self.advisory.graph.connection(&tx))
            .await?;

        let mut assertions = HashMap::new();

        for each in fixed_versions {
            let package_key = Purl {
                ty: each.ty,
                namespace: each.namespace,
                name: each.name,
                version: None,
                qualifiers: Default::default(),
            }
            .to_string();

            let mut package_assertions = assertions.entry(package_key.clone()).or_insert(vec![]);

            package_assertions.push(Assertion::Fixed {
                version: each.version,
            });
        }

        Ok(AdvisoryVulnerabilityAssertions { assertions })
    }
}

#[cfg(test)]
mod test {
    use crate::graph::Graph;
    use test_log::test;
    use trustify_common::advisory::Assertion;
    use trustify_common::db::{Database, Transactional};

    #[test(tokio::test)]
    async fn advisory_affected_vulnerability_assertions() -> Result<(), anyhow::Error> {
        let db = Database::for_test("advisory_affected_vulnerability_assertions").await?;
        let system = Graph::new(db);

        let advisory = system
            .ingest_advisory(
                "RHSA-GHSA-1",
                "http://db.com/rhsa-ghsa-2",
                "2",
                (),
                Transactional::None,
            )
            .await?;

        let advisory_vulnerability = advisory
            .link_to_vulnerability("CVE-42", Transactional::None)
            .await?;

        advisory_vulnerability
            .ingest_affected_package_range(
                "pkg://maven/io.quarkus/quarkus-core".try_into()?,
                "1.0.2",
                "1.2.0",
                Transactional::None,
            )
            .await?;

        advisory_vulnerability
            .ingest_not_affected_package_version(
                "pkg://maven/.io.quarkus/quarkus-core@1.1.9".try_into()?,
                Transactional::None,
            )
            .await?;

        let affected = advisory_vulnerability
            .affected_assertions(Transactional::None)
            .await?;

        assert_eq!(1, affected.assertions.len());

        Ok(())
    }

    #[test(tokio::test)]
    async fn advisory_not_affected_vulnerability_assertions() -> Result<(), anyhow::Error> {
        let db = Database::for_test("advisory_not_affected_vulnerability_assertions").await?;
        let system = Graph::new(db);

        let advisory = system
            .ingest_advisory(
                "RHSA-GHSA-1",
                "http://db.com/rhsa-ghsa-2",
                "2",
                (),
                Transactional::None,
            )
            .await?;

        let advisory_vulnerability = advisory
            .link_to_vulnerability("INTERAL-77", Transactional::None)
            .await?;

        advisory_vulnerability
            .ingest_affected_package_range(
                "pkg://maven/io.quarkus/quarkus-core".try_into()?,
                "1.0.2",
                "1.2.0",
                Transactional::None,
            )
            .await?;

        advisory_vulnerability
            .ingest_not_affected_package_version(
                "pkg://maven/io.quarkus/quarkus-core@1.1.9".try_into()?,
                Transactional::None,
            )
            .await?;

        let not_affected = advisory_vulnerability
            .not_affected_assertions(Transactional::None)
            .await?;

        assert_eq!(1, not_affected.assertions.len());

        let pkg_assertions = not_affected
            .assertions
            .get(&"pkg://maven/io.quarkus/quarkus-core".to_string());

        assert!(pkg_assertions.is_some());

        let pkg_assertions = pkg_assertions.unwrap();

        assert_eq!(1, pkg_assertions.len());

        let assertion = &pkg_assertions[0];

        assert!(matches!( assertion, Assertion::NotAffected {version, ..}
            if version == "1.1.9"
        ));

        Ok(())
    }
}
