//! Support for CVEs.

use crate::graph::advisory::AdvisoryContext;
use crate::graph::error::Error;
use crate::graph::Graph;
use sea_orm::ActiveValue::Set;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, EntityTrait, ModelTrait, QueryFilter, QuerySelect, RelationTrait,
};
use sea_query::{Condition, JoinType};
use std::fmt::{Debug, Formatter};
use time::OffsetDateTime;
use trustify_common::db::Transactional;
use trustify_entity as entity;
use trustify_entity::{advisory, advisory_vulnerability, vulnerability, vulnerability_description};

#[derive(Clone, Default)]
pub struct VulnerabilityInformation {
    pub title: Option<String>,
    pub published: Option<OffsetDateTime>,
    pub modified: Option<OffsetDateTime>,
    pub withdrawn: Option<OffsetDateTime>,
}

impl VulnerabilityInformation {
    pub fn has_data(&self) -> bool {
        self.title.is_some()
            || self.published.is_some()
            || self.modified.is_some()
            || self.withdrawn.is_some()
    }
}

impl From<()> for VulnerabilityInformation {
    fn from(_: ()) -> Self {
        Self {
            title: None,
            published: None,
            modified: None,
            withdrawn: None,
        }
    }
}

impl Graph {
    pub async fn ingest_vulnerability<
        I: Into<VulnerabilityInformation>,
        TX: AsRef<Transactional>,
    >(
        &self,
        identifier: &str,
        information: I,
        tx: TX,
    ) -> Result<VulnerabilityContext, Error> {
        let information = information.into();
        if let Some(found) = self.get_vulnerability(identifier, &tx).await? {
            if information.has_data() {
                // we should update with the details.
                let mut entity = vulnerability::ActiveModel::from(found.vulnerability);
                entity.title = Set(information.title);
                entity.published = Set(information.published);
                entity.modified = Set(information.modified);
                entity.withdrawn = Set(information.withdrawn);
                let model = entity.update(&self.connection(&tx)).await?;
                Ok(VulnerabilityContext::new(&found.graph, model))
            } else {
                Ok(found)
            }
        } else {
            let entity = vulnerability::ActiveModel {
                id: Default::default(),
                identifier: Set(identifier.to_string()),
                title: Set(information.title),
                published: Set(information.published),
                modified: Set(information.modified),
                withdrawn: Set(information.withdrawn),
            };

            Ok(VulnerabilityContext::new(
                self,
                entity.insert(&self.connection(&tx)).await?,
            ))
        }
    }

    pub async fn get_vulnerability<TX: AsRef<Transactional>>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find()
            .filter(vulnerability::Column::Identifier.eq(identifier))
            .one(&self.connection(&tx))
            .await?
            .map(|cve| VulnerabilityContext::new(self, cve)))
    }

    pub async fn get_vulnerabilities<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<VulnerabilityContext>, Error> {
        Ok(entity::vulnerability::Entity::find()
            .filter(Condition::all())
            .all(&self.connection(&tx))
            .await?
            .into_iter()
            .map(|vulnerability| VulnerabilityContext::new(self, vulnerability))
            .collect())
    }
}

#[derive(Clone)]
pub struct VulnerabilityContext {
    pub graph: Graph,
    pub vulnerability: vulnerability::Model,
}

impl Debug for VulnerabilityContext {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.vulnerability.fmt(f)
    }
}

impl VulnerabilityContext {
    pub fn new(graph: &Graph, vulnerability: vulnerability::Model) -> Self {
        Self {
            graph: graph.clone(),
            vulnerability,
        }
    }

    pub async fn advisories<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<AdvisoryContext>, Error> {
        Ok(advisory::Entity::find()
            .join(
                JoinType::Join,
                advisory_vulnerability::Relation::Advisory.def().rev(),
            )
            .filter(advisory_vulnerability::Column::VulnerabilityId.eq(self.vulnerability.id))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(0..)
            .map(|advisory| AdvisoryContext::new(&self.graph, advisory))
            .collect())
    }

    pub async fn add_description<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        description: &str,
        tx: TX,
    ) -> Result<(), Error> {
        let model = vulnerability_description::ActiveModel {
            id: Default::default(),
            vulnerability_id: Set(self.vulnerability.id),
            lang: Set(lang.to_string()),
            description: Set(description.to_string()),
        };

        model.save(&self.graph.connection(&tx)).await?;

        Ok(())
    }

    pub async fn descriptions<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        tx: TX,
    ) -> Result<Vec<String>, Error> {
        Ok(self
            .vulnerability
            .find_related(entity::vulnerability_description::Entity)
            .filter(vulnerability_description::Column::Lang.eq(lang))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(..)
            .map(|e| e.description)
            .collect())
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use crate::graph::Graph;
    use test_context::test_context;
    use test_log::test;
    use trustify_common::db::{test::TrustifyContext, Transactional};
    use trustify_common::hashing::Digests;

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn ingest_cves(ctx: TrustifyContext) -> Result<(), anyhow::Error> {
        let db = ctx.db;
        let system = Graph::new(db);

        let cve1 = system
            .ingest_vulnerability("CVE-123", (), Transactional::None)
            .await?;
        let cve2 = system
            .ingest_vulnerability("CVE-123", (), Transactional::None)
            .await?;
        let cve3 = system
            .ingest_vulnerability("CVE-456", (), Transactional::None)
            .await?;

        assert_eq!(cve1.vulnerability.id, cve2.vulnerability.id);
        assert_ne!(cve1.vulnerability.id, cve3.vulnerability.id);

        let not_found = system
            .get_vulnerability("CVE-NOT_FOUND", Transactional::None)
            .await?;

        assert!(not_found.is_none());

        Ok(())
    }

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn get_advisories_from_cve(ctx: TrustifyContext) -> Result<(), anyhow::Error> {
        let db = ctx.db;
        let system = Graph::new(db);

        let advisory1 = system
            .ingest_advisory(
                "GHSA-1",
                ("source", "http://ghsa.io/GHSA-1"),
                &Digests::digest("GHSA-1"),
                (),
                Transactional::None,
            )
            .await?;

        let advisory2 = system
            .ingest_advisory(
                "RHSA-1",
                ("source", "http://rhsa.io/RHSA-1"),
                &Digests::digest("RHSA-1"),
                (),
                Transactional::None,
            )
            .await?;

        let _advisory3 = system
            .ingest_advisory(
                "SNYK-1",
                ("source", "http://snyk.io/SNYK-1"),
                &Digests::digest("SNYK-1"),
                (),
                Transactional::None,
            )
            .await?;

        advisory1
            .link_to_vulnerability("CVE-8675309", None, Transactional::None)
            .await?;

        advisory2
            .link_to_vulnerability("CVE-8675309", None, Transactional::None)
            .await?;

        let cve = system
            .get_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        assert!(cve.is_some());

        let cve = cve.unwrap();

        let linked_advisories = cve.advisories(Transactional::None).await?;

        assert_eq!(2, linked_advisories.len());

        assert!(linked_advisories.contains(&advisory1));
        assert!(linked_advisories.contains(&advisory2));

        Ok(())
    }
}
