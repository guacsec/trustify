//! Support for CVEs.

use crate::{graph::advisory::AdvisoryContext, graph::error::Error, graph::Graph};
use sea_orm::{
    ActiveModelTrait, ActiveValue::Set, ColumnTrait, DbErr, EntityTrait, ModelTrait, QueryFilter,
    QuerySelect, RelationTrait,
};
use sea_query::JoinType;
use std::fmt::{Debug, Formatter};
use time::OffsetDateTime;
use tracing::instrument;
use trustify_common::db::{chunk::EntityChunkedIter, Transactional};
use trustify_entity::{advisory, advisory_vulnerability, vulnerability, vulnerability_description};
use uuid::Uuid;

#[derive(Clone, Default)]
pub struct VulnerabilityInformation {
    pub title: Option<String>,
    pub published: Option<OffsetDateTime>,
    pub modified: Option<OffsetDateTime>,
    pub withdrawn: Option<OffsetDateTime>,
    pub cwe: Option<String>,
}

impl VulnerabilityInformation {
    pub fn has_data(&self) -> bool {
        self.title.is_some()
            || self.published.is_some()
            || self.modified.is_some()
            || self.withdrawn.is_some()
            || self.cwe.is_some()
    }
}

impl From<()> for VulnerabilityInformation {
    fn from(_: ()) -> Self {
        Self {
            title: None,
            published: None,
            modified: None,
            withdrawn: None,
            cwe: None,
        }
    }
}

impl Graph {
    #[instrument(skip(self, information, tx), err)]
    pub async fn ingest_vulnerability<
        I: Into<VulnerabilityInformation>,
        TX: AsRef<Transactional>,
    >(
        &self,
        identifier: &str,
        information: I,
        tx: TX,
    ) -> Result<VulnerabilityContext, Error> {
        // TODO: consider transforming into upsert
        let information = information.into();
        if let Some(found) = self.get_vulnerability(identifier, &tx).await? {
            if information.has_data() {
                // we should update with the details.
                let mut entity = vulnerability::ActiveModel::from(found.vulnerability);
                entity.title = Set(information.title.clone());
                entity.published = Set(information.published);
                entity.modified = Set(information.modified);
                entity.withdrawn = Set(information.withdrawn);

                match entity.update(&self.connection(&tx)).await {
                    Ok(model) => Ok(VulnerabilityContext::new(&found.graph, model)),
                    Err(err) => {
                        if let DbErr::RecordNotUpdated = err {
                            // there turns out to not be a row in the DB, so
                            // attempt an insert instead of an update.
                            let entity = vulnerability::ActiveModel {
                                id: Set(identifier.to_string()),
                                title: Set(information.title),
                                published: Set(information.published),
                                modified: Set(information.modified),
                                withdrawn: Set(information.withdrawn),
                                cwe: Default::default(),
                            };

                            let model = entity.insert(&self.connection(&tx)).await?;
                            Ok(VulnerabilityContext::new(&found.graph, model))
                        } else {
                            Err(Error::from(err))
                        }
                    }
                }
            } else {
                Ok(found)
            }
        } else {
            let entity = vulnerability::ActiveModel {
                id: Set(identifier.to_string()),
                title: Set(information.title),
                published: Set(information.published),
                modified: Set(information.modified),
                withdrawn: Set(information.withdrawn),
                cwe: Set(information.cwe),
            };

            Ok(VulnerabilityContext::new(
                self,
                entity.insert(&self.connection(&tx)).await?,
            ))
        }
    }

    #[instrument(skip(self, tx), err)]
    pub async fn get_vulnerability(
        &self,
        identifier: &str,
        tx: impl AsRef<Transactional>,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find_by_id(identifier)
            .one(&self.connection(&tx))
            .await?
            .map(|vuln| VulnerabilityContext::new(self, vuln)))
    }

    #[instrument(skip(self, tx), err)]
    pub async fn get_vulnerabilities<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find()
            .all(&self.connection(&tx))
            .await?
            .into_iter()
            .map(|vulnerability| VulnerabilityContext::new(self, vulnerability))
            .collect())
    }
}

#[derive(Clone)]
pub struct VulnerabilityContext {
    pub graph: Graph,
    pub vulnerability: vulnerability::Model,
}

impl Debug for VulnerabilityContext {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.vulnerability.fmt(f)
    }
}

impl VulnerabilityContext {
    pub fn new(graph: &Graph, vulnerability: vulnerability::Model) -> Self {
        Self {
            graph: graph.clone(),
            vulnerability,
        }
    }

    pub async fn advisories<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<AdvisoryContext>, Error> {
        Ok(advisory::Entity::find()
            .join(
                JoinType::Join,
                advisory_vulnerability::Relation::Advisory.def().rev(),
            )
            .filter(
                advisory_vulnerability::Column::VulnerabilityId.eq(self.vulnerability.id.clone()),
            )
            .all(&self.graph.connection(&tx))
            .await?
            .drain(0..)
            .map(|advisory| AdvisoryContext::new(&self.graph, advisory))
            .collect())
    }

    pub async fn add_description<TX: AsRef<Transactional>>(
        &self,
        advisory: Uuid,
        lang: &str,
        description: &str,
        tx: TX,
    ) -> Result<(), Error> {
        self.add_descriptions(advisory, [(lang, description)], tx)
            .await
    }

    pub async fn add_descriptions<TX: AsRef<Transactional>>(
        &self,
        advisory: Uuid,
        descriptions: impl IntoIterator<Item = (&str, &str)>,
        tx: TX,
    ) -> Result<(), Error> {
        let entries = descriptions.into_iter().map(|(lang, description)| {
            vulnerability_description::ActiveModel {
                id: Default::default(),
                advisory_id: Set(advisory),
                vulnerability_id: Set(self.vulnerability.id.clone()),
                lang: Set(lang.to_string()),
                description: Set(description.to_string()),
            }
        });

        let db = self.graph.connection(&tx);

        for batch in &entries.chunked() {
            vulnerability_description::Entity::insert_many(batch)
                .exec(&db)
                .await?;
        }

        Ok(())
    }

    pub async fn drop_descriptions_for_advisory<TX: AsRef<Transactional>>(
        &self,
        advisory: Uuid,
        tx: TX,
    ) -> Result<(), Error> {
        let db = self.graph.connection(&tx);

        vulnerability_description::Entity::delete_many()
            .filter(vulnerability_description::Column::AdvisoryId.eq(advisory))
            .exec(&db)
            .await?;

        Ok(())
    }

    // Get all descriptions for a vulnerability
    pub async fn descriptions<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        tx: TX,
    ) -> Result<Vec<String>, Error> {
        Ok(self
            .vulnerability
            .find_related(vulnerability_description::Entity)
            .filter(vulnerability_description::Column::Lang.eq(lang))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(..)
            .map(|e| e.description)
            .collect())
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use crate::graph::Graph;
    use test_context::test_context;
    use test_log::test;
    use trustify_common::db::Transactional;
    use trustify_common::hashing::Digests;
    use trustify_test_context::TrustifyContext;

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn ingest_cves(ctx: TrustifyContext) -> Result<(), anyhow::Error> {
        let db = ctx.db;
        let system = Graph::new(db);

        println!("A");
        let cve1 = system
            .ingest_vulnerability("CVE-123", (), Transactional::None)
            .await?;
        println!("B");
        let cve2 = system
            .ingest_vulnerability("CVE-123", (), Transactional::None)
            .await?;
        println!("C");
        let cve3 = system
            .ingest_vulnerability("CVE-456", (), Transactional::None)
            .await?;
        println!("D");

        assert_eq!(cve1.vulnerability.id, cve2.vulnerability.id);
        assert_ne!(cve1.vulnerability.id, cve3.vulnerability.id);

        let not_found = system
            .get_vulnerability("CVE-NOT_FOUND", Transactional::None)
            .await?;

        assert!(not_found.is_none());

        Ok(())
    }

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn get_advisories_from_cve(ctx: TrustifyContext) -> Result<(), anyhow::Error> {
        let db = ctx.db;
        let system = Graph::new(db);

        let advisory1 = system
            .ingest_advisory(
                "GHSA-1",
                ("source", "http://ghsa.io/GHSA-1"),
                &Digests::digest("GHSA-1"),
                (),
                Transactional::None,
            )
            .await?;

        let advisory2 = system
            .ingest_advisory(
                "RHSA-1",
                ("source", "http://rhsa.io/RHSA-1"),
                &Digests::digest("RHSA-1"),
                (),
                Transactional::None,
            )
            .await?;

        let _advisory3 = system
            .ingest_advisory(
                "SNYK-1",
                ("source", "http://snyk.io/SNYK-1"),
                &Digests::digest("SNYK-1"),
                (),
                Transactional::None,
            )
            .await?;

        advisory1
            .link_to_vulnerability("CVE-8675309", None, Transactional::None)
            .await?;

        advisory2
            .link_to_vulnerability("CVE-8675309", None, Transactional::None)
            .await?;

        let cve = system
            .get_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        assert!(cve.is_some());

        let cve = cve.unwrap();

        let linked_advisories = cve.advisories(Transactional::None).await?;

        assert_eq!(2, linked_advisories.len());

        assert!(linked_advisories.contains(&advisory1));
        assert!(linked_advisories.contains(&advisory2));

        Ok(())
    }
}
