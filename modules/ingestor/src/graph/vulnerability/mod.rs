//! Support for CVEs.

use crate::graph::advisory::AdvisoryContext;
use crate::graph::error::Error;
use crate::graph::Graph;
use sea_orm::ActiveValue::{Set, Unchanged};
use sea_orm::{
    ActiveModelTrait, ColumnTrait, EntityTrait, ModelTrait, NotSet, QueryFilter, QueryOrder,
    QuerySelect, RelationTrait,
};
use sea_query::JoinType;
use std::fmt::{Debug, Formatter};
use std::str::FromStr;
use trustify_common::db::limiter::LimiterTrait;
use trustify_common::db::Transactional;
use trustify_common::model::{Paginated, PaginatedResults};
use trustify_entity as entity;
use trustify_entity::cvss3::Relation::Vulnerability;
use trustify_entity::vulnerability::Model;
use trustify_entity::{advisory, advisory_vulnerability, vulnerability, vulnerability_description};
use trustify_module_search::model::SearchOptions;
use trustify_module_search::query::Query;

impl Graph {
    pub async fn vulnerabilities<TX: AsRef<Transactional>>(
        &self,
        search: SearchOptions,
        paginated: Paginated,
        tx: TX,
    ) -> Result<PaginatedResults<VulnerabilityContext>, Error> {
        let connection = self.connection(&tx);

        let limiter = vulnerability::Entity::find().filtering(search)?.limiting(
            &connection,
            paginated.offset,
            paginated.limit,
        );

        Ok(PaginatedResults {
            total: limiter.total().await?,
            items: limiter
                .fetch()
                .await?
                .drain(0..)
                .map(|each| VulnerabilityContext::new(self, each))
                .collect(),
        })
    }

    pub async fn ingest_vulnerability<TX: AsRef<Transactional>>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<VulnerabilityContext, Error> {
        if let Some(found) = self.get_vulnerability(identifier, &tx).await? {
            Ok(found)
        } else {
            let entity = vulnerability::ActiveModel {
                id: Default::default(),
                identifier: Set(identifier.to_string()),
                title: NotSet,
            };

            Ok(VulnerabilityContext::new(
                self,
                entity.insert(&self.connection(&tx)).await?,
            ))
        }
    }

    pub async fn get_vulnerability<TX: AsRef<Transactional>>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find()
            .filter(vulnerability::Column::Identifier.eq(identifier))
            .one(&self.connection(&tx))
            .await?
            .map(|cve| VulnerabilityContext::new(self, cve)))
    }
}

#[derive(Clone)]
pub struct VulnerabilityContext {
    pub graph: Graph,
    pub vulnerability: vulnerability::Model,
}

impl Debug for VulnerabilityContext {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.vulnerability.fmt(f)
    }
}

impl VulnerabilityContext {
    pub fn new(graph: &Graph, vulnerability: vulnerability::Model) -> Self {
        Self {
            graph: graph.clone(),
            vulnerability,
        }
    }

    pub async fn advisories<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<AdvisoryContext>, Error> {
        Ok(advisory::Entity::find()
            .join(
                JoinType::Join,
                advisory_vulnerability::Relation::Advisory.def().rev(),
            )
            .filter(advisory_vulnerability::Column::VulnerabilityId.eq(self.vulnerability.id))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(0..)
            .map(|advisory| AdvisoryContext::new(&self.graph, advisory))
            .collect())
    }

    pub async fn set_title<TX: AsRef<Transactional>>(
        &self,
        title: Option<String>,
        tx: TX,
    ) -> Result<(), Error> {
        let mut entity: vulnerability::ActiveModel = self.vulnerability.clone().into();
        entity.title = Set(title);
        entity.save(&self.graph.connection(&tx)).await?;
        Ok(())
    }

    pub async fn add_description<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        description: &str,
        tx: TX,
    ) -> Result<(), Error> {
        let model = vulnerability_description::ActiveModel {
            id: Default::default(),
            vulnerability_id: Set(self.vulnerability.id),
            lang: Set(lang.to_string()),
            description: Set(description.to_string()),
        };

        model.save(&self.graph.connection(&tx)).await?;

        Ok(())
    }

    pub async fn descriptions<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        tx: TX,
    ) -> Result<Vec<String>, Error> {
        Ok(self
            .vulnerability
            .find_related(entity::vulnerability_description::Entity)
            .filter(vulnerability_description::Column::Lang.eq(lang))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(..)
            .map(|e| e.description)
            .collect())
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use crate::graph::Graph;
    use test_log::test;
    use trustify_common::db::{Database, Transactional};

    #[test(tokio::test)]
    async fn ingest_cves() -> Result<(), anyhow::Error> {
        let db = Database::for_test("ingest_cve").await?;
        let system = Graph::new(db);

        let cve1 = system
            .ingest_vulnerability("CVE-123", Transactional::None)
            .await?;
        let cve2 = system
            .ingest_vulnerability("CVE-123", Transactional::None)
            .await?;
        let cve3 = system
            .ingest_vulnerability("CVE-456", Transactional::None)
            .await?;

        assert_eq!(cve1.vulnerability.id, cve2.vulnerability.id);
        assert_ne!(cve1.vulnerability.id, cve3.vulnerability.id);

        let not_found = system
            .get_vulnerability("CVE-NOT_FOUND", Transactional::None)
            .await?;

        assert!(not_found.is_none());

        Ok(())
    }

    #[test(tokio::test)]
    async fn get_advisories_from_cve() -> Result<(), anyhow::Error> {
        let db = Database::for_test("get_advisories_from_cve").await?;
        let system = Graph::new(db);

        let advisory1 = system
            .ingest_advisory(
                "GHSA-1",
                "http://ghsa.io/GHSA-1",
                "7",
                (),
                Transactional::None,
            )
            .await?;

        let advisory2 = system
            .ingest_advisory(
                "RHSA-1",
                "http://rhsa.io/RHSA-1",
                "8",
                (),
                Transactional::None,
            )
            .await?;

        let advisory3 = system
            .ingest_advisory(
                "SNYK-1",
                "http://snyk.io/SNYK-1",
                "9",
                (),
                Transactional::None,
            )
            .await?;

        advisory1
            .link_to_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        advisory2
            .link_to_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        let cve = system
            .get_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        assert!(cve.is_some());

        let cve = cve.unwrap();

        let linked_advisories = cve.advisories(Transactional::None).await?;

        assert_eq!(2, linked_advisories.len());

        assert!(linked_advisories.contains(&advisory1));
        assert!(linked_advisories.contains(&advisory2));

        Ok(())
    }
}
