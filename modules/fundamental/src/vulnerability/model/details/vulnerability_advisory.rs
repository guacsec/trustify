use crate::advisory::model::AdvisoryHead;
use crate::package::model::PackageHead;
use crate::Error;
use sea_orm::{
    ColumnTrait, EntityTrait, FromQueryResult, LoaderTrait, QueryFilter, QuerySelect, RelationTrait,
};
use sea_query::JoinType;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use trustify_common::db::ConnectionOrTransaction;
use trustify_common::purl::Purl;
use trustify_cvss::cvss3::score::Score;
use trustify_cvss::cvss3::Cvss3Base;
use trustify_entity::{
    advisory, cvss3, package, package_status, status, version_range, vulnerability,
};
use utoipa::ToSchema;
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryHead {
    #[serde(flatten)]
    pub head: AdvisoryHead,
    pub severity: Option<String>,
    pub score: Option<f64>,
}

impl VulnerabilityAdvisoryHead {
    pub async fn from_entity(
        vulnerability: &vulnerability::Model,
        advisory: &advisory::Model,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Self, Error> {
        let cvss3 = cvss3::Entity::find()
            .filter(cvss3::Column::AdvisoryId.eq(advisory.id))
            .filter(cvss3::Column::VulnerabilityId.eq(vulnerability.id))
            .all(tx)
            .await?;

        let total_score = cvss3
            .iter()
            .map(|e| {
                let base = Cvss3Base::from(e.clone());
                base.score().value()
            })
            .reduce(|accum, e| accum + e);

        let score = total_score.map(|score| Score::new(score / cvss3.len() as f64));

        Ok(VulnerabilityAdvisoryHead {
            head: AdvisoryHead::from_entity(advisory, None, tx).await?,
            severity: score.map(|score| score.severity().to_string()),
            score: score.map(|score| score.value()),
        })
    }
    pub async fn from_entities(
        vulnerability: &vulnerability::Model,
        advisories: &[advisory::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let cvss3s = advisories
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::VulnerabilityId.eq(vulnerability.id)),
                tx,
            )
            .await?;

        let mut heads = Vec::new();

        for (advisory, cvss3) in advisories.iter().zip(cvss3s.iter()) {
            let total_score = cvss3
                .iter()
                .map(|e| {
                    let base = Cvss3Base::from(e.clone());
                    base.score().value()
                })
                .reduce(|accum, e| accum + e);

            let score = total_score.map(|score| Score::new(score / cvss3.len() as f64));

            heads.push(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_entity(advisory, None, tx).await?,
                severity: score.map(|score| score.severity().to_string()),
                score: score.map(|score| score.value()),
            });
        }

        Ok(heads)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisorySummary {
    #[serde(flatten)]
    pub head: VulnerabilityAdvisoryHead,
    #[schema(default, value_type = Vec < String >)]
    pub cvss3_scores: Vec<String>,
    pub statuses: HashMap<String, Vec<VulnerabilityAdvisoryStatus>>,
}

impl VulnerabilityAdvisorySummary {
    pub async fn from_entities(
        vulnerability: &vulnerability::Model,
        advisories: &[advisory::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let mut summaries = Vec::new();

        let mut cvss3s = advisories
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::VulnerabilityId.eq(vulnerability.id)),
                tx,
            )
            .await?;

        for (advisory, mut cvss3) in advisories.iter().zip(cvss3s.drain(..)) {
            let cvss3_scores = cvss3
                .drain(..)
                .map(|e| Cvss3Base::from(e).to_string())
                .collect();

            let statuses = package_status::Entity::find()
                .columns([
                    version_range::Column::LowVersion,
                    version_range::Column::LowInclusive,
                    version_range::Column::HighVersion,
                    version_range::Column::HighInclusive,
                ])
                .column_as(status::Column::Slug, "status")
                .columns([
                    package::Column::Type,
                    package::Column::Name,
                    package::Column::Namespace,
                ])
                .left_join(status::Entity)
                .filter(package_status::Column::VulnerabilityId.eq(vulnerability.id))
                .filter(package_status::Column::AdvisoryId.eq(advisory.id))
                .left_join(package::Entity)
                .column_as(package::Column::Id, "package_uuid")
                .join(JoinType::LeftJoin, package::Relation::PackageVersions.def())
                .left_join(version_range::Entity)
                .distinct_on([package_status::Column::Id])
                .into_model::<StatusCatcher>()
                .all(tx)
                .await?;

            summaries.push(VulnerabilityAdvisorySummary {
                head: VulnerabilityAdvisoryHead::from_entity(vulnerability, advisory, tx).await?,
                cvss3_scores,
                statuses: VulnerabilityAdvisoryStatus::from_models(&statuses, tx).await?,
            });
        }

        Ok(summaries)
    }
}

#[derive(FromQueryResult, Debug)]
struct StatusCatcher {
    status: String,
    package_uuid: Uuid,
    r#type: String,
    namespace: Option<String>,
    name: String,
    low_version: Option<String>,
    low_inclusive: Option<bool>,
    high_version: Option<String>,
    high_inclusive: Option<bool>,
}

impl StatusCatcher {
    pub fn purl(&self) -> Purl {
        Purl {
            ty: self.r#type.clone(),
            namespace: self.namespace.clone(),
            name: self.name.clone(),
            version: None,
            qualifiers: Default::default(),
        }
    }

    pub fn version(&self) -> String {
        match (&self.low_version, &self.high_version) {
            (Some(low), Some(high)) if low == high => low.clone(),
            (Some(low), Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.high_inclusive));
                v
            }

            (Some(low), None) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push(Self::close_delim(self.high_inclusive));
                v
            }
            (None, Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.low_inclusive));
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.high_inclusive));
                v
            }
            (None, None) => "*".to_string(),
        }
    }

    fn open_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                '['
            } else {
                '('
            }
        } else {
            '('
        }
    }

    fn close_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                ']'
            } else {
                ')'
            }
        } else {
            ')'
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryStatus {
    package: PackageHead,
    version: String,
}

impl VulnerabilityAdvisoryStatus {
    async fn from_models(
        models: &Vec<StatusCatcher>,
        _tx: &ConnectionOrTransaction<'_>,
    ) -> Result<HashMap<String, Vec<Self>>, Error> {
        let mut statuses = HashMap::new();

        for each in models {
            let status_entry = statuses.entry(each.status.clone()).or_insert(vec![]);
            status_entry.push(VulnerabilityAdvisoryStatus {
                package: PackageHead {
                    uuid: each.package_uuid,
                    purl: each.purl(),
                },
                version: each.version(),
            });
        }

        Ok(statuses)
    }
}
