use crate::purl::model::details::purl::StatusContext;
use crate::purl::model::PurlHead;
use crate::sbom::model::SbomHead;
use crate::{advisory::model::AdvisoryHead, purl::model::BasePurlHead, Error};
use cpe::uri::OwnedUri;
use sea_orm::{
    ColumnTrait, EntityTrait, FromQueryResult, LoaderTrait, ModelTrait, QueryFilter, QuerySelect,
    RelationTrait,
};
use sea_query::{Asterisk, Expr, Func, JoinType, SimpleExpr};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use trustify_common::db::VersionMatches;
use trustify_common::id::Id;
use trustify_common::{
    cpe::CpeCompare, db::ConnectionOrTransaction, impl_try_into_cpe, purl::Purl,
};
use trustify_cvss::{cvss3::score::Score, cvss3::Cvss3Base};
use trustify_entity as entity;
use trustify_entity::labels::Labels;
use trustify_entity::relationship::Relationship;
use utoipa::ToSchema;
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryHead {
    #[serde(flatten)]
    pub head: AdvisoryHead,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub score: Option<f64>,
}

impl VulnerabilityAdvisoryHead {
    pub async fn from_entity(
        vulnerability_identifier: &str,
        advisory_vulnerability: &entity::advisory_vulnerability::Model,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Self, Error> {
        let cvss3 = entity::cvss3::Entity::find()
            .filter(entity::cvss3::Column::AdvisoryId.eq(advisory_vulnerability.advisory_id))
            .filter(entity::cvss3::Column::VulnerabilityId.eq(vulnerability_identifier))
            .all(tx)
            .await?;

        let total_score = cvss3
            .iter()
            .map(|e| {
                let base = Cvss3Base::from(e.clone());
                base.score().value()
            })
            .reduce(|accum, e| accum + e);

        let score = total_score.map(|score| Score::new(score / cvss3.len() as f64));

        if let Some(advisory) = &advisory_vulnerability
            .find_related(entity::advisory::Entity)
            .one(tx)
            .await?
        {
            Ok(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, None, tx).await?,
                severity: score.map(|score| score.severity().to_string()),
                score: score.map(|score| score.value()),
            })
        } else {
            Err(Error::Data("Underlying advisory is missing".to_string()))
        }
    }
    pub async fn from_entities(
        vulnerability: &entity::vulnerability::Model,
        advisories: &[entity::advisory::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let cvss3s = advisories
            .load_many(
                entity::cvss3::Entity::find()
                    .filter(entity::cvss3::Column::VulnerabilityId.eq(&vulnerability.id)),
                tx,
            )
            .await?;

        let mut heads = Vec::new();

        for (advisory, cvss3) in advisories.iter().zip(cvss3s.iter()) {
            let total_score = cvss3
                .iter()
                .map(|e| {
                    let base = Cvss3Base::from(e.clone());
                    base.score().value()
                })
                .reduce(|accum, e| accum + e);

            let score = total_score.map(|score| Score::new(score / cvss3.len() as f64));

            heads.push(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, None, tx).await?,
                severity: score.map(|score| score.severity().to_string()),
                score: score.map(|score| score.value()),
            });
        }

        Ok(heads)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisorySummary {
    #[serde(flatten)]
    pub head: VulnerabilityAdvisoryHead,
    #[schema(default, value_type = Vec < String >)]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub cvss3_scores: Vec<String>,
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub purls: HashMap<String, Vec<VulnerabilityAdvisoryStatus>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sboms: Vec<SbomStatus>,
}

impl VulnerabilityAdvisorySummary {
    pub async fn from_entities(
        vulnerability_identifier: &str,
        advisory_vulnerabilities: &[entity::advisory_vulnerability::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let mut summaries = Vec::new();

        let mut cvss3s = advisory_vulnerabilities
            .load_many(
                entity::cvss3::Entity::find()
                    .filter(entity::cvss3::Column::VulnerabilityId.eq(vulnerability_identifier)),
                tx,
            )
            .await?;

        for (advisory_vulnerability, mut cvss3) in
            advisory_vulnerabilities.iter().zip(cvss3s.drain(..))
        {
            let cvss3_scores = cvss3
                .drain(..)
                .map(|e| Cvss3Base::from(e).to_string())
                .collect();

            let statuses = entity::purl_status::Entity::find()
                .columns([
                    entity::version_range::Column::LowVersion,
                    entity::version_range::Column::LowInclusive,
                    entity::version_range::Column::HighVersion,
                    entity::version_range::Column::HighInclusive,
                ])
                .column_as(entity::status::Column::Slug, "status")
                .columns([
                    entity::base_purl::Column::Type,
                    entity::base_purl::Column::Name,
                    entity::base_purl::Column::Namespace,
                ])
                .left_join(entity::status::Entity)
                .filter(entity::purl_status::Column::VulnerabilityId.eq(vulnerability_identifier))
                .filter(
                    entity::purl_status::Column::AdvisoryId.eq(advisory_vulnerability.advisory_id),
                )
                .left_join(entity::base_purl::Entity)
                .column_as(entity::base_purl::Column::Id, "package_uuid")
                .join(
                    JoinType::LeftJoin,
                    entity::base_purl::Relation::VersionedPurls.def(),
                )
                .left_join(entity::version_range::Entity)
                .left_join(entity::cpe::Entity)
                .column_as(entity::cpe::Column::Id, "cpe_id")
                .columns([
                    entity::cpe::Column::Part,
                    entity::cpe::Column::Vendor,
                    entity::cpe::Column::Product,
                    entity::cpe::Column::Version,
                    entity::cpe::Column::Update,
                    entity::cpe::Column::Edition,
                    entity::cpe::Column::Language,
                ])
                .distinct_on([entity::purl_status::Column::Id])
                .into_model::<PurlStatusCatcher>()
                .all(tx)
                .await?;

            let status_ids = statuses.iter().map(|e| e.id).collect::<Vec<_>>();

            let sbom_purl_statuses = entity::sbom_package::Entity::find()
                .join(JoinType::Join, entity::sbom_package::Relation::Node.def())
                .join(
                    JoinType::LeftJoin,
                    entity::sbom_package::Relation::Purl.def(),
                )
                .join(
                    JoinType::LeftJoin,
                    entity::sbom_package_purl_ref::Relation::Purl.def(),
                )
                .join(
                    JoinType::LeftJoin,
                    entity::qualified_purl::Relation::VersionedPurl.def(),
                )
                .join(
                    JoinType::LeftJoin,
                    entity::versioned_purl::Relation::BasePurl.def(),
                )
                .join(
                    JoinType::Join,
                    entity::base_purl::Relation::PurlStatus.def(),
                )
                .join(JoinType::Join, entity::purl_status::Relation::Status.def())
                .join(
                    JoinType::LeftJoin,
                    entity::purl_status::Relation::VersionRange.def(),
                )
                .join(
                    JoinType::LeftJoin,
                    entity::purl_status::Relation::ContextCpe.def(),
                )
                .column_as(
                    Expr::col((
                        entity::versioned_purl::Entity,
                        entity::versioned_purl::Column::Version,
                    )),
                    "version",
                )
                .column_as(entity::status::Column::Slug, "status")
                .column_as(entity::cpe::Column::Id, "cpe_id")
                .columns([
                    entity::cpe::Column::Part,
                    entity::cpe::Column::Vendor,
                    entity::cpe::Column::Product,
                    entity::cpe::Column::Version,
                    entity::cpe::Column::Update,
                    entity::cpe::Column::Edition,
                    entity::cpe::Column::Language,
                ])
                .filter(entity::purl_status::Column::VulnerabilityId.eq(vulnerability_identifier))
                .filter(entity::purl_status::Column::Id.is_in(status_ids))
                .filter(SimpleExpr::FunctionCall(
                    Func::cust(VersionMatches)
                        .arg(Expr::col((
                            entity::versioned_purl::Entity,
                            entity::versioned_purl::Column::Version,
                        )))
                        .arg(Expr::col((entity::version_range::Entity, Asterisk))),
                ))
                .into_model::<SbomStatusCatcher>()
                .all(tx)
                .await?;

            summaries.push(VulnerabilityAdvisorySummary {
                head: VulnerabilityAdvisoryHead::from_entity(
                    vulnerability_identifier,
                    advisory_vulnerability,
                    tx,
                )
                .await?,
                cvss3_scores,
                purls: VulnerabilityAdvisoryStatus::from_models(&statuses, tx).await?,
                sboms: SbomStatus::from_models(&sbom_purl_statuses, tx).await?,
            });
        }

        Ok(summaries)
    }
}

#[derive(FromQueryResult, Debug)]
struct PurlStatusCatcher {
    id: Uuid,
    status: String,
    package_uuid: Uuid,
    r#type: String,
    namespace: Option<String>,
    name: String,
    low_version: Option<String>,
    low_inclusive: Option<bool>,
    high_version: Option<String>,
    high_inclusive: Option<bool>,
    part: Option<String>,
    vendor: Option<String>,
    product: Option<String>,
    version: Option<String>,
    update: Option<String>,
    edition: Option<String>,
    language: Option<String>,
}

impl_try_into_cpe!(PurlStatusCatcher);

impl PurlStatusCatcher {
    pub fn purl(&self) -> Purl {
        Purl {
            ty: self.r#type.clone(),
            namespace: self.namespace.clone(),
            name: self.name.clone(),
            version: None,
            qualifiers: Default::default(),
        }
    }

    pub fn version(&self) -> String {
        match (&self.low_version, &self.high_version) {
            (Some(low), Some(high)) if low == high => low.clone(),
            (Some(low), Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.high_inclusive));
                v
            }

            (Some(low), None) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push(Self::close_delim(self.high_inclusive));
                v
            }
            (None, Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.low_inclusive));
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.high_inclusive));
                v
            }
            (None, None) => "*".to_string(),
        }
    }

    fn open_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                '['
            } else {
                '('
            }
        } else {
            '('
        }
    }

    fn close_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl {
                ']'
            } else {
                ')'
            }
        } else {
            ')'
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryStatus {
    pub base_purl: BasePurlHead,
    pub version: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<StatusContext>,
}

impl VulnerabilityAdvisoryStatus {
    async fn from_models(
        models: &Vec<PurlStatusCatcher>,
        _tx: &ConnectionOrTransaction<'_>,
    ) -> Result<HashMap<String, Vec<Self>>, Error> {
        let mut statuses = HashMap::new();

        for each in models {
            let mut context = None;

            let cpe: Result<OwnedUri, _> = each.try_into();
            if let Ok(cpe) = cpe {
                context = Some(StatusContext::Cpe(cpe.to_string()));
            }

            let status_entry = statuses.entry(each.status.clone()).or_insert(vec![]);
            status_entry.push(VulnerabilityAdvisoryStatus {
                base_purl: BasePurlHead {
                    uuid: each.package_uuid,
                    purl: each.purl(),
                },
                version: each.version(),
                context,
            });
        }

        Ok(statuses)
    }
}

#[derive(Debug, FromQueryResult)]
struct SbomStatusCatcher {
    sbom_id: Uuid,
    status: String,
    cpe_id: Option<Uuid>,
    part: Option<String>,
    vendor: Option<String>,
    product: Option<String>,
    version: Option<String>,
    update: Option<String>,
    edition: Option<String>,
    language: Option<String>,
}

impl_try_into_cpe!(SbomStatusCatcher);

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SbomStatus {
    #[serde(flatten)]
    pub head: SbomHead,

    pub version: Option<String>,
    #[serde(skip)]
    cpe: Option<OwnedUri>,

    pub status: HashSet<String>,
}

impl SbomStatus {
    async fn from_models(
        sbom_purl_status: &[SbomStatusCatcher],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let mut sboms = HashMap::new();

        for sbom_id in sbom_purl_status
            .iter()
            .map(|e| e.sbom_id)
            .collect::<HashSet<_>>()
        {
            let sbom_status = if let Some(sbom_details) =
                entity::package_relates_to_package::Entity::find()
                    .filter(entity::package_relates_to_package::Column::SbomId.eq(sbom_id))
                    .filter(
                        entity::package_relates_to_package::Column::Relationship
                            .eq(Relationship::DescribedBy),
                    )
                    .join(
                        JoinType::LeftJoin,
                        entity::package_relates_to_package::Relation::Left.def(),
                    )
                    .join(
                        JoinType::LeftJoin,
                        entity::sbom_node::Relation::Package.def(),
                    )
                    .join(
                        JoinType::LeftJoin,
                        entity::sbom_package::Relation::Cpe.def(),
                    )
                    .join(
                        JoinType::LeftJoin,
                        entity::sbom_package_cpe_ref::Relation::Cpe.def(),
                    )
                    .join(JoinType::Join, entity::sbom_package::Relation::Sbom.def())
                    .column_as(entity::sbom_package::Column::Version, "sbom_version")
                    .column(entity::sbom_node::Column::Name)
                    .columns([
                        entity::sbom::Column::SbomId,
                        entity::sbom::Column::Sha256,
                        entity::sbom::Column::Sha384,
                        entity::sbom::Column::Sha512,
                        entity::sbom::Column::Labels,
                        entity::sbom::Column::DocumentId,
                        entity::sbom::Column::Published,
                        entity::sbom::Column::Authors,
                    ])
                    .column_as(entity::cpe::Column::Id, "cpe_id")
                    .columns([
                        entity::cpe::Column::Part,
                        entity::cpe::Column::Vendor,
                        entity::cpe::Column::Product,
                        entity::cpe::Column::Version,
                        entity::cpe::Column::Update,
                        entity::cpe::Column::Edition,
                        entity::cpe::Column::Language,
                    ])
                    .into_model::<SbomDetailsCatcher>()
                    .one(tx)
                    .await?
            {
                let sbom_cpe: Result<OwnedUri, _> = (&sbom_details).try_into();
                let sbom_cpe = sbom_cpe.ok();

                let mut hashes = vec![Id::Sha256(sbom_details.sha256)];

                if let Some(hash) = sbom_details.sha384 {
                    hashes.push(Id::Sha384(hash));
                }

                if let Some(hash) = sbom_details.sha512 {
                    hashes.push(Id::Sha512(hash));
                }

                SbomStatus {
                    head: SbomHead {
                        id: sbom_details.sbom_id,
                        hashes,
                        document_id: sbom_details.document_id,
                        labels: sbom_details.labels,
                        name: sbom_details.name,
                    },
                    version: sbom_details.sbom_version,
                    cpe: sbom_cpe,
                    status: Default::default(),
                }
            } else {
                SbomStatus {
                    head: SbomHead {
                        id: sbom_id,
                        hashes: vec![],
                        document_id: "".to_string(),
                        labels: Default::default(),
                        name: "".to_string(),
                    },
                    version: None,
                    cpe: None,
                    status: Default::default(),
                }
            };

            sboms.insert(sbom_id, sbom_status);
        }

        'status: for advisory_status in sbom_purl_status {
            if let Some(sbom_status) = sboms.get_mut(&advisory_status.sbom_id) {
                match (advisory_status.cpe_id, &sbom_status.cpe) {
                    (Some(_advisory_cpe), Some(sbom_cpe)) => {
                        let status_cpe: Result<OwnedUri, _> = advisory_status.try_into();

                        if let Ok(status_cpe) = status_cpe {
                            if status_cpe.is_superset(sbom_cpe) {
                                // the status context *is* applicable, fall through
                            } else {
                                // the status context *is not* applicable, skip
                                continue 'status;
                            }
                        } else {
                            // status_cpe is malformed, skip
                            continue 'status;
                        }
                    }
                    (Some(_), None) => {
                        // Advisory has context that does not apply to this sbom, skip
                        continue 'status;
                    }
                    (None, _) => {
                        // Advisory is not contextualized around a given CPE, fall through
                    }
                }

                sbom_status.status.insert(advisory_status.status.clone());
            }
        }

        Ok(sboms.values().cloned().collect())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SbomPackageStatus {
    Cpe(),
    Purl(PurlHead),
}

#[derive(Debug, FromQueryResult)]
struct SbomDetailsCatcher {
    sbom_id: Uuid,

    sha256: String,
    sha384: Option<String>,
    sha512: Option<String>,
    document_id: String,

    name: String,
    sbom_version: Option<String>,
    labels: Labels,

    part: Option<String>,
    vendor: Option<String>,
    product: Option<String>,
    version: Option<String>,
    update: Option<String>,
    edition: Option<String>,
    language: Option<String>,
}

impl_try_into_cpe!(SbomDetailsCatcher);
