mod vulnerability_advisory;

pub use vulnerability_advisory::*;

use crate::{Error, vulnerability::model::VulnerabilityHead};
use sea_orm::{ConnectionTrait, ModelTrait};
use serde::{Deserialize, Serialize};
use tracing::{info_span, instrument};
use tracing_futures::Instrument;
use trustify_common::memo::Memo;
use trustify_cvss::cvss3::severity::Severity;
use trustify_entity::{advisory_vulnerability, cvss3, vulnerability};
use trustify_module_ingestor::common::{Deprecation, DeprecationForExt};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityDetails {
    #[serde(flatten)]
    pub head: VulnerabilityHead,

    /// Average (arithmetic mean) severity of the vulnerability aggregated from *all* related advisories.
    #[schema(required)]
    pub average_severity: Option<Severity>,

    /// Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
    #[schema(required)]
    pub average_score: Option<f64>,

    /// Advisories addressing this vulnerability, if any.
    pub advisories: Vec<VulnerabilityAdvisorySummary>,
}

impl VulnerabilityDetails {
    #[instrument(
        skip(vulnerability, tx),
        fields(
            vulnerability=vulnerability.id,
        )
        err(level=tracing::Level::INFO),
    )]
    pub async fn from_entity<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        deprecation: Deprecation,
        tx: &C,
    ) -> Result<Self, Error> {
        let advisory_vulnerabilities = vulnerability
            .find_related(advisory_vulnerability::Entity)
            .with_deprecation_related(deprecation)
            .all(tx)
            .instrument(info_span!("find related"))
            .await?;

        let cvss3 = vulnerability
            .find_related(cvss3::Entity)
            .all(tx)
            .instrument(info_span!("find scores"))
            .await?;

        let advisories = VulnerabilityAdvisorySummary::from_entities(
            vulnerability,
            &advisory_vulnerabilities,
            &cvss3,
            tx,
        )
        .await?;

        Ok(VulnerabilityDetails {
            head: VulnerabilityHead::from_vulnerability_entity(
                vulnerability,
                Memo::NotProvided,
                tx,
            )
            .await?,
            average_severity: vulnerability.base_severity.map(|s| s.into()),
            average_score: vulnerability.base_score,
            advisories,
        })
    }
}
