mod details;
mod summary;

pub use details::*;
use sea_orm::{LoaderTrait, ModelTrait};
pub use summary::*;

use crate::Error;
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;
use trustify_common::db::ConnectionOrTransaction;
use trustify_entity::{advisory_vulnerability, vulnerability, vulnerability_description};
use utoipa::ToSchema;

fn is_false(val: &bool) -> bool {
    !(*val)
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityHead {
    #[serde(default, skip_serializing_if = "is_false")]
    pub normative: bool,
    pub identifier: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[serde(with = "time::serde::rfc3339::option")]
    pub published: Option<OffsetDateTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[serde(with = "time::serde::rfc3339::option")]
    pub modified: Option<OffsetDateTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[serde(with = "time::serde::rfc3339::option")]
    pub withdrawn: Option<OffsetDateTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[serde(with = "time::serde::rfc3339::option")]
    pub discovered: Option<OffsetDateTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[serde(with = "time::serde::rfc3339::option")]
    pub released: Option<OffsetDateTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cwe: Option<String>,
}

impl VulnerabilityHead {
    pub async fn from_vulnerability_entity(
        entity: &vulnerability::Model,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Self, Error> {
        let description = entity
            .find_related(vulnerability_description::Entity)
            .one(tx)
            .await?
            .filter(|model| model.lang == "en")
            .map(|model| model.description);

        Ok(Self::from_vulnerability_entity_and_description(
            entity,
            description,
        ))
    }

    pub fn from_vulnerability_entity_and_description(
        entity: &vulnerability::Model,
        description: Option<String>,
    ) -> Self {
        Self {
            normative: true,
            identifier: entity.id.clone(),
            title: entity.title.clone(),
            description,
            published: entity.published,
            modified: entity.modified,
            withdrawn: entity.withdrawn,
            discovered: None,
            released: None,
            cwe: entity.cwe.clone(),
        }
    }

    pub fn from_advisory_vulnerability_entity(
        advisory_vulnerability: &advisory_vulnerability::Model,
        vuln: &vulnerability::Model,
    ) -> Self {
        Self {
            normative: false,
            identifier: vuln.id.clone(),
            title: advisory_vulnerability.title.clone(),
            description: advisory_vulnerability.description.clone(),
            published: None,
            modified: None,
            withdrawn: None,
            discovered: advisory_vulnerability.discovery_date,
            released: advisory_vulnerability.release_date,
            cwe: advisory_vulnerability.cwe.clone(),
        }
    }

    pub async fn from_vulnerability_entities(
        entities: &[vulnerability::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let descriptions = entities
            .load_many(vulnerability_description::Entity, tx)
            .await?
            .into_iter()
            .map(|model| {
                model
                    .into_iter()
                    .filter(|desc| desc.lang == "en")
                    .map(|desc| desc.description)
                    .next()
            });

        Ok(entities
            .iter()
            .zip(descriptions)
            .map(|(vuln, desc)| Self::from_vulnerability_entity_and_description(vuln, desc))
            .collect())
    }
}
