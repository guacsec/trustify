use crate::{advisory::model::AdvisoryHead, vulnerability::model::VulnerabilityHead};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::{collections::BTreeMap, ops::Deref};
use trustify_cvss::cvss3::severity::Severity;
use utoipa::{
    PartialSchema, ToSchema,
    openapi::{
        ObjectBuilder, RefOr, Schema, Type, extensions::ExtensionsBuilder, schema::SchemaType,
    },
};

#[derive(Serialize, Deserialize, Debug, ToSchema)]
pub struct AnalysisRequest {
    pub purls: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, ToSchema)]
pub struct AnalysisDetails {
    #[serde(flatten)]
    pub head: VulnerabilityHead,

    /// Map of status to advisories
    ///
    /// Allowed status values:
    /// - `affected`: Advisories that affect the package
    /// - `under_investigation`: Advisories that might affect the package, but the investigation is still ongoing
    ///
    /// Additional status values may be added in the future; see API documentation for details.
    pub status: BTreeMap<String, Vec<AnalysisAdvisory>>,
}

#[derive(Serialize, Deserialize, Debug, ToSchema)]
pub struct AnalysisAdvisory {
    #[serde(flatten)]
    pub advisory: AdvisoryHead,

    /// CVSS scores
    pub scores: Vec<Score>,
}

/// The type of score, indicating the scoring system and version used.
#[derive(Clone, Copy, Serialize, Deserialize, Debug, Eq, PartialEq, strum::VariantArray)]
pub enum ScoreType {
    /// CVSS v2.0 score
    #[serde(rename = "2.0")]
    V2,
    /// CVSS v3.0 score
    #[serde(rename = "3.0")]
    V3,
    /// CVSS v3.1 score
    #[serde(rename = "3.1")]
    V3_1,
    /// CVSS v4.0 score
    #[serde(rename = "4.0")]
    V4,
}

impl PartialSchema for ScoreType {
    fn schema() -> RefOr<Schema> {
        Schema::Object(
            ObjectBuilder::new()
                .schema_type(SchemaType::Type(Type::String))
                .description(Some(
                    "The type of score, indicating the scoring system and version used.",
                ))
                .enum_values(Some(["2.0", "3.0", "3.1", "4.0"]))
                .extensions(Some(
                    ExtensionsBuilder::new()
                        .add(
                            "x-enum-descriptions",
                            json!([
                                "CVSS v2.0 score",
                                "CVSS v3.0 score",
                                "CVSS v3.1 score",
                                "CVSS v4.0 score",
                            ]),
                        )
                        .build(),
                ))
                .build(),
        )
        .into()
    }
}

impl ToSchema for ScoreType {}

#[derive(Clone, Copy, Serialize, Deserialize, Debug, ToSchema, PartialEq)]
pub struct Score {
    /// The score type
    pub r#type: ScoreType,
    /// The actual value
    pub value: f64,
    /// The derived severity
    pub severity: Severity,
}

#[derive(Serialize, Deserialize, Debug, ToSchema)]
pub struct AnalysisResponse(pub BTreeMap<String, Vec<AnalysisDetails>>);

impl Deref for AnalysisResponse {
    type Target = BTreeMap<String, Vec<AnalysisDetails>>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use strum::VariantArray;

    #[test]
    fn ensure_schema_variants() {
        let RefOr::T(Schema::Object(schema)) = ScoreType::schema() else {
            panic!("must but a concrete object");
        };

        // ensure the base type is a string

        assert!(matches!(schema.schema_type, SchemaType::Type(Type::String)));

        // ensure we have as many enum variants as in our Rust type, and that they match

        assert_eq!(
            schema.enum_values,
            Some(
                ScoreType::VARIANTS
                    .iter()
                    .map(|v| json!(v))
                    .collect::<Vec<_>>()
            )
        );

        // ensure that we have the same entries in the extension description

        let ext = &schema.extensions.unwrap()["x-enum-descriptions"];
        let serde_json::Value::Array(items) = ext else {
            panic!("must be an array")
        };

        assert_eq!(
            items,
            &ScoreType::VARIANTS
                .iter()
                .map(|v| {
                    let v = json!(v).to_string();
                    let v = v.trim_matches('\"');
                    format!("CVSS v{v} score")
                })
                .collect::<Vec<_>>()
        );
    }
}
