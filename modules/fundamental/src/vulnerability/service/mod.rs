use std::{collections::HashMap, str::FromStr};

use crate::{
    Error,
    vulnerability::model::{VulnerabilityDetails, VulnerabilitySummary},
};
use futures_util::{TryFutureExt, TryStreamExt};
use sea_orm::{EntityTrait, Statement, StreamTrait, prelude::*};
use trustify_common::{
    db::{
        limiter::LimiterTrait,
        query::{Columns, Filtering, Query},
    },
    model::{Paginated, PaginatedResults},
    purl::{Purl, PurlErr},
};
use trustify_entity::vulnerability;
use trustify_module_ingestor::common::Deprecation;

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let limiter = vulnerability::Entity::find()
            .filtering_with(search, Columns::from_entity::<vulnerability::Entity>())?
            .limiting(connection, paginated.offset, paginated.limit);

        let total = limiter.total().await?;
        let vulnerabilities = limiter.fetch().await?;

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(&vulnerabilities, deprecation, connection)
                .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }

    pub async fn analyze_purls<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<HashMap<String, Vec<VulnerabilityDetails>>, Error>
    where
        C: ConnectionTrait + StreamTrait,
    {
        let query = purls
            .into_iter()
            .map(|p| {
                let p = p.as_ref();
                let purl = Purl::from_str(p)?;

                let ns_condition = match &purl.namespace {
                    Some(namespace) => {
                        let sql = "base_purl.namespace = $1";
                        Statement::from_sql_and_values(
                            connection.get_database_backend(),
                            sql,
                            [namespace.into()],
                        )
                    }
                    None => Statement::from_string(
                        connection.get_database_backend(),
                        "base_purl.namespace IS NULL",
                    ),
                };

                let values = [
                    p.into(),
                    purl.name.into(),
                    purl.ty.into(),
                    purl.version.ok_or_else(|| PurlErr::MissingVersion(p.to_owned()))?.into(),
                ];
                let sql = format!(r#"
                  SELECT $1 as requested_purl,
                    vulnerability.id, vulnerability.title, vulnerability.reserved,
                    vulnerability.published, vulnerability.modified, vulnerability.withdrawn, vulnerability.cwes
                  FROM base_purl
                    LEFT JOIN purl_status ON base_purl.id = purl_status.base_purl_id
                    INNER JOIN version_range ON purl_status.version_range_id = version_range.id
                    LEFT JOIN vulnerability ON purl_status.vulnerability_id = vulnerability.id
                    INNER JOIN status ON purl_status.status_id = status.id
                  WHERE {ns_condition}
                    AND base_purl.name = $2
                    AND base_purl.type = $3
                    AND version_matches($4, version_range.*) = TRUE
                    AND status.slug != 'fixed'"#);
                let query =
                    Statement::from_sql_and_values(connection.get_database_backend(), &sql, values);
                Ok(query.to_string())
            })
            .collect::<Result<Vec<String>, Error>>()?
            .join(" UNION ALL ");

        let stmt = Statement::from_string(connection.get_database_backend(), query);
        let result = connection.stream(stmt).map_err(Error::from).await?;
        let result = result
            .map_err(Error::from)
            .and_then(|row| self.to_vuln(row, connection))
            .try_fold(
                HashMap::new(),
                |mut acc: HashMap<String, Vec<VulnerabilityDetails>>,
                 (requested_purl, vuln_details)| async {
                    acc.entry(requested_purl).or_default().push(vuln_details);
                    Ok(acc)
                },
            )
            .await?;

        Ok(result)
    }

    async fn to_vuln<C: ConnectionTrait>(
        &self,
        row: QueryResult,
        connection: &C,
    ) -> Result<(String, VulnerabilityDetails), Error> {
        let requested_purl: String = row.try_get("", "requested_purl")?;
        let vulnerability = vulnerability::Model {
            id: row.try_get("", "id")?,
            title: row.try_get("", "title")?,
            reserved: row.try_get("", "reserved")?,
            published: row.try_get("", "published")?,
            modified: row.try_get("", "modified")?,
            withdrawn: row.try_get("", "withdrawn")?,
            cwes: row.try_get("", "cwes")?,
            base_score: row.try_get("", "base_score")?,
            base_severity: row.try_get("", "base_severity")?,
        };
        let vuln_details =
            VulnerabilityDetails::from_entity(&vulnerability, Deprecation::Ignore, connection)
                .await;
        match vuln_details {
            Ok(details) => Ok((requested_purl, details)),
            Err(e) => Err(e),
        }
    }
}

#[cfg(test)]
mod test;
