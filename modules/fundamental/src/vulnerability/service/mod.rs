use sea_orm::{prelude::*, EntityTrait, QueryFilter, QuerySelect};

use crate::vulnerability::model::{VulnerabilityDetails, VulnerabilitySummary};
use crate::Error;
use trustify_common::db::limiter::LimiterTrait;
use trustify_common::db::query::{Filtering, Query};
use trustify_common::db::Database;
use trustify_common::db::Transactional;
use trustify_common::model::{Paginated, PaginatedResults};
use trustify_entity::{advisory_vulnerability, vulnerability};

pub struct VulnerabilityService {
    db: Database,
}

impl VulnerabilityService {
    pub fn new(db: Database) -> Self {
        Self { db }
    }

    pub async fn fetch_vulnerabilities<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        tx: TX,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let connection = self.db.connection(&tx);

        let limiter = vulnerability::Entity::find()
            .right_join(advisory_vulnerability::Entity)
            .column_as(
                advisory_vulnerability::Column::VulnerabilityId,
                vulnerability::Column::Id,
            )
            .distinct_on([advisory_vulnerability::Column::VulnerabilityId])
            .filtering(search)?
            .limiting(&connection, paginated.offset, paginated.limit);

        let total = limiter.total().await?;

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(&limiter.fetch().await?, &connection)
                .await?,
        })
    }

    pub async fn fetch_vulnerability<TX: AsRef<Transactional> + Sync + Send>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        let connection = self.db.connection(&tx);

        if let Some(vulnerability) = vulnerability::Entity::find()
            .filter(vulnerability::Column::Id.eq(identifier))
            .one(&connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, &connection).await?,
            ))
        } else {
            // no root vulnerability has been ingested, so let's see if there's
            // any advisories referencing it.

            let advisory_vulns = advisory_vulnerability::Entity::find()
                .filter(advisory_vulnerability::Column::VulnerabilityId.eq(identifier))
                .all(&connection)
                .await?;

            if advisory_vulns.is_empty() {
                Ok(None)
            } else {
                Ok(Some(
                    VulnerabilityDetails::from_advisory_vulnerabilities(
                        identifier,
                        &advisory_vulns,
                        &connection,
                    )
                    .await?,
                ))
            }
        }
    }
}

#[cfg(test)]
mod test;
