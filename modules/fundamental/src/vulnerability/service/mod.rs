use crate::{
    Error,
    advisory::model::AdvisoryHead,
    vulnerability::model::{
        AnalysisDetails, AnalysisResponse, VulnerabilityDetails, VulnerabilityHead,
        VulnerabilitySummary,
    },
};
use futures_util::{TryFutureExt, TryStreamExt};
use sea_orm::{
    EntityTrait, FromQueryResult, Statement, StreamTrait, TryGetableFromJson, prelude::*,
};
use std::{
    collections::{BTreeMap, HashMap},
    str::FromStr,
};
use tracing::instrument;
use trustify_common::{
    db::{
        limiter::LimiterTrait,
        query::{Columns, Filtering, Query},
    },
    memo::Memo,
    model::{Paginated, PaginatedResults},
    purl::{Purl, PurlErr},
};
use trustify_entity::{advisory, vulnerability};
use trustify_module_ingestor::common::Deprecation;

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let limiter = vulnerability::Entity::find()
            .filtering_with(search, Columns::from_entity::<vulnerability::Entity>())?
            .limiting(connection, paginated.offset, paginated.limit);

        let total = limiter.total().await?;
        let vulnerabilities = limiter.fetch().await?;

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(&vulnerabilities, deprecation, connection)
                .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    #[instrument(
        skip(self, connection),
        err(level=tracing::Level::INFO),
    )]
    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }

    #[instrument(
        skip_all,
        err(level=tracing::Level::INFO),
    )]
    pub async fn analyze_purls<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<AnalysisResponse, Error>
    where
        C: ConnectionTrait + StreamTrait,
    {
        let query = Self::build_query(purls, connection)?;

        let stmt = Statement::from_string(connection.get_database_backend(), query);
        log::debug!("Analyzing using: {stmt}");
        let result = connection.stream(stmt).map_err(Error::from).await?;
        let result = result
            .map_err(Error::from)
            .and_then(|row| Self::row_to_vuln(row, connection))
            .try_fold(
                BTreeMap::new(),
                |mut acc: BTreeMap<String, Vec<AnalysisDetails>>, (requested_purl, head)| async {
                    acc.entry(requested_purl).or_default().push(head);
                    Ok(acc)
                },
            )
            .await?;

        Ok(AnalysisResponse(result))
    }

    /// Build the query for finding matching vulnerabilities
    fn build_query(
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &impl ConnectionTrait,
    ) -> Result<String, Error> {
        let query = purls
            .into_iter()
            .map(|p| {
                let p = p.as_ref();
                let purl = Purl::from_str(p)?;

                let ns_condition = match &purl.namespace {
                    Some(namespace) => {
                        let sql = "base_purl.namespace = $1";
                        Statement::from_sql_and_values(
                            connection.get_database_backend(),
                            sql,
                            [namespace.into()],
                        )
                        .to_string()
                    }
                    None => "base_purl.namespace IS NULL".to_string(),
                };

                let sql = format!(
                    r#"
SELECT
  $1 as requested_purl,
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  jsonb_agg(
    jsonb_build_object(
      'status', status.slug,
      'id', purl_status.advisory_id
    )
  ) AS advisories
FROM base_purl
  LEFT JOIN purl_status ON base_purl.id = purl_status.base_purl_id
  INNER JOIN version_range ON purl_status.version_range_id = version_range.id
  LEFT JOIN vulnerability ON purl_status.vulnerability_id = vulnerability.id
  INNER JOIN status ON purl_status.status_id = status.id
WHERE {ns_condition}
  AND base_purl.name = $2
  AND base_purl.type = $3
  AND version_matches($4, version_range.*) = TRUE
  AND status.slug NOT IN (
    'fixed',
    'not_affected',
    'recommended'
  )
GROUP BY
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  requested_purl
"#
                );
                let query = Statement::from_sql_and_values(
                    connection.get_database_backend(),
                    &sql,
                    [
                        p.into(),
                        purl.name.into(),
                        purl.ty.into(),
                        purl.version
                            .ok_or_else(|| PurlErr::MissingVersion(p.to_owned()))?
                            .into(),
                    ],
                );
                Ok(query.to_string())
            })
            .collect::<Result<Vec<String>, Error>>()?
            .join(" UNION ALL ");

        Ok(query)
    }

    /// Take a row from [`Self::build_query`] and turn it into a result entry
    ///
    /// This will return a tuple of the original PURL and then the result
    #[instrument(
        skip_all,
        fields(purl, id),
        err(level=tracing::Level::INFO),
    )]
    async fn row_to_vuln<C>(
        row: QueryResult,
        connection: &C,
    ) -> Result<(String, AnalysisDetails), Error>
    where
        C: ConnectionTrait + StreamTrait,
    {
        let requested_purl: String = row.try_get_by("requested_purl")?;

        let vulnerability = vulnerability::Model::from_query_result(&row, "")?;

        let span = tracing::Span::current();
        span.record("purl", &requested_purl);
        span.record("id", &vulnerability.id);

        let head = VulnerabilityHead::from_vulnerability_entity(
            &vulnerability,
            Memo::NotProvided,
            connection,
        )
        .await?;

        /// result struct for getting the array of status/advisory entries
        #[derive(serde::Deserialize)]
        struct Entry {
            status: String,
            id: Uuid,
        }

        impl TryGetableFromJson for Entry {}

        // deserialize from JSONB

        let advisories: Option<Vec<Entry>> = row.try_get_by("advisories")?;
        let ids = advisories
            .iter()
            .flatten()
            .map(|e| e.id)
            .collect::<Vec<_>>();

        // create a map for looking up the status once we resolved the ID to a struct
        let statuses = advisories
            .into_iter()
            .flatten()
            .map(|e| (e.id, e.status))
            .collect::<HashMap<_, _>>();

        // query for all advisories and translate into map

        let status = advisory::Entity::find()
            .filter(advisory::Column::Id.is_in(ids))
            .stream(connection)
            .await?
            .map_err(Error::from)
            .try_filter_map(async |advisory| {
                let Some(status) = statuses.get(&advisory.id) else {
                    return Ok(None);
                };
                Ok(Some((
                    status.clone(),
                    AdvisoryHead::from_advisory(&advisory, Memo::NotProvided, connection).await?,
                )))
            })
            .try_fold(
                BTreeMap::<String, Vec<AdvisoryHead>>::new(),
                async move |mut acc, (status, adv)| {
                    acc.entry(status.clone()).or_default().push(adv);
                    Ok(acc)
                },
            )
            .await?;

        Ok((requested_purl, AnalysisDetails { head, status }))
    }
}

#[cfg(test)]
mod test;
