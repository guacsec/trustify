mod vulnerability_advisory;
pub use vulnerability_advisory::*;

use crate::vulnerability::VulnerabilityHead;
use crate::Error;
use sea_orm::{EntityTrait, LoaderTrait, ModelTrait};
use serde::{Deserialize, Serialize};
use trustify_common::db::ConnectionOrTransaction;
use trustify_entity::{advisory, vulnerability};
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityDetails {
    #[serde(flatten)]
    pub head: VulnerabilityHead,
    pub advisories: Vec<VulnerabilityAdvisorySummary>,
}

impl VulnerabilityDetails {
    pub async fn from_entity(
        entity: &vulnerability::Model,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Option<Self>, Error> {
        let advisories = entity.find_related(advisory::Entity).all(tx).await?;

        let advisories =
            VulnerabilityAdvisorySummary::from_entities(entity, &advisories, tx).await?;

        Ok(VulnerabilityHead::from_entity(entity, tx)
            .await?
            .map(|head| VulnerabilityDetails { head, advisories }))
    }

    pub async fn from_entities(
        entities: &[vulnerability::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let advisories = entities.load_many(advisory::Entity::find(), tx).await?;

        let mut details = Vec::new();

        for (vuln, advisories) in entities.iter().zip(advisories.iter()) {
            if let Some(head) = VulnerabilityHead::from_entity(vuln, tx).await? {
                details.push(VulnerabilityDetails {
                    head,
                    advisories: VulnerabilityAdvisorySummary::from_entities(vuln, advisories, tx)
                        .await?,
                })
            }
        }

        Ok(details)
    }
}
