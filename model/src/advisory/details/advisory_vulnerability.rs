use std::collections::HashMap;

use sea_orm::{ColumnTrait, EntityTrait, LoaderTrait, QueryFilter};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use trustify_common::advisory::{AdvisoryVulnerabilityAssertions, Assertion};
use trustify_common::db::ConnectionOrTransaction;
use trustify_common::purl::Purl;
use trustify_cvss::cvss3::score::Score;
use trustify_cvss::cvss3::Cvss3Base;
use trustify_entity::{
    advisory, affected_package_version_range, cvss3, fixed_package_version,
    not_affected_package_version, package, package_version, package_version_range, vulnerability,
};

use crate::vulnerability::VulnerabilityHead;
use crate::Error;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct AdvisoryVulnerabilityHead {
    #[serde(flatten)]
    pub head: VulnerabilityHead,
    pub severity: String,
    pub score: f64,
}

impl AdvisoryVulnerabilityHead {
    pub async fn from_entity(
        vulnerability: &vulnerability::Model,
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Option<Self>, Error> {
        Ok(VulnerabilityHead::from_entity(vulnerability, tx)
            .await?
            .map(|head| AdvisoryVulnerabilityHead {
                head,
                severity: "".to_string(),
                score: 0.0,
            }))
    }

    pub async fn from_entities(
        advisory: &advisory::Model,
        vulnerabilities: &[vulnerability::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let cvss3s = vulnerabilities
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut heads = Vec::new();

        for (vuln, cvss3) in vulnerabilities.iter().zip(cvss3s.iter()) {
            let score = if let Some(average) = cvss3
                .iter()
                .map(|e| {
                    let base = Cvss3Base::from(e.clone());
                    base.score().value()
                })
                .reduce(|accum, e| accum + e)
            {
                Score::new(average / cvss3.len() as f64)
            } else {
                Score::new(0.0)
            };
            if let Some(head) = VulnerabilityHead::from_entity(vuln, tx).await? {
                heads.push(AdvisoryVulnerabilityHead {
                    head,
                    severity: score.severity().to_string(),
                    score: score.value(),
                });
            }
        }

        Ok(heads)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct AdvisoryVulnerabilitySummary {
    #[serde(flatten)]
    pub head: AdvisoryVulnerabilityHead,
    #[schema(default, value_type = Vec < String >)]
    pub cvss3_scores: Vec<String>,
    #[serde(flatten)]
    pub assertions: AdvisoryVulnerabilityAssertions,
}

impl AdvisoryVulnerabilitySummary {
    pub async fn from_entities(
        advisory: &advisory::Model,
        vulnerabilities: &[vulnerability::Model],
        tx: &ConnectionOrTransaction<'_>,
    ) -> Result<Vec<Self>, Error> {
        let mut fixed = vulnerabilities
            .load_many(
                fixed_package_version::Entity::find()
                    .filter(fixed_package_version::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut affected = vulnerabilities
            .load_many(
                affected_package_version_range::Entity::find()
                    .filter(affected_package_version_range::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut not_affected = vulnerabilities
            .load_many(
                not_affected_package_version::Entity::find()
                    .filter(not_affected_package_version::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut cvss3s = vulnerabilities
            .load_many(
                cvss3::Entity::find().filter(cvss3::Column::AdvisoryId.eq(advisory.id)),
                tx,
            )
            .await?;

        let mut summaries = Vec::new();

        for ((((vuln, fixed), affected), not_affected), mut cvss3) in vulnerabilities
            .iter()
            .zip(fixed.drain(..))
            .zip(affected.drain(..))
            .zip(not_affected.drain(..))
            .zip(cvss3s.drain(..))
        {
            let mut assertions = HashMap::new();

            // fixed
            {
                let mut package_versions = fixed
                    .load_one(package_version::Entity, tx)
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_versions.load_one(package::Entity, tx).await?;

                packages.drain(..).zip(package_versions.drain(..)).for_each(
                    |(package, version)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::Fixed {
                                version: version.version,
                            })
                        }
                    },
                );
            }

            // affected
            {
                let mut package_version_ranges = affected
                    .load_one(package_version_range::Entity, tx)
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_version_ranges
                    .load_one(package::Entity, tx)
                    .await?
                    .drain(..)
                    .collect::<Vec<_>>();

                packages
                    .drain(..)
                    .zip(package_version_ranges.drain(..))
                    .for_each(|(package, version_range)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::Affected {
                                start_version: version_range.start,
                                end_version: version_range.end,
                            })
                        }
                    });
            }

            // not affected
            {
                let mut package_versions = not_affected
                    .load_one(package_version::Entity, tx)
                    .await?
                    .iter()
                    .flat_map(|e| e.clone())
                    .collect::<Vec<_>>();

                let mut packages = package_versions
                    .load_one(package::Entity, tx)
                    .await?
                    .drain(..)
                    .collect::<Vec<_>>();

                packages.drain(..).zip(package_versions.drain(..)).for_each(
                    |(package, version)| {
                        if let Some(package) = package {
                            let package_assertions = assertions
                                .entry(
                                    Purl {
                                        ty: package.r#type,
                                        namespace: package.namespace,
                                        name: package.name,
                                        version: None,
                                        qualifiers: Default::default(),
                                    }
                                    .to_string(),
                                )
                                .or_insert(vec![]);

                            package_assertions.push(Assertion::NotAffected {
                                version: version.version,
                            })
                        }
                    },
                );

                let cvss3_scores = cvss3
                    .drain(..)
                    .map(|e| Cvss3Base::from(e).to_string())
                    .collect();

                if let Some(head) = AdvisoryVulnerabilityHead::from_entity(vuln, tx).await? {
                    summaries.push(AdvisoryVulnerabilitySummary {
                        head,
                        cvss3_scores,
                        assertions: Default::default(),
                    });
                }
            }
        }

        Ok(summaries)
    }
}
