# Labels

## Rationale

We currently have a `location` (sometimes named `source`) field for things that we import. The idea behind it is to
track the "source" where the document came from to allow limiting operations based on this information. Examples could
be: delete all SBOMs where `source=ci-a`, or list and filter by `source=redhat`.

On the other side, it seems weird to force/require exactly one field for a specific purpose.

## Idea

Instead of having a single field for the location, it would be possible to add "labels" to those documents. A document
could have zero or more labels of an arbitrary key value pairs (both strings). For
example: `source=redhat`, `ci=job-a`, `team=chickens`. Keys would be unique and have only a single value.

Each document would have a `HashMap<String, String>` (or similar structure).

Labels could be provided by the user, or even auto-generated by the system.

### Implementation

PostgreSQL has an `hstore` extension, which is targeting the key/value pair use case. It seems like a perfect fit for
this.

Each document would get a new field called `labels` of the type `hstore`. Using a `GIN` index, we can speed up
certain queries on the content of the field.

For querying, we can use the same operators as for JSONB.

We can search for documents having a label of that type (by key) or for documents having a label with a specific value
(by key = value). While it might be interesting to search by arrays of values (contains) or substrings, I would not
say we start with this.

The only downside of this approach for our cause seems to be the fact that it isn't easily possible to evaluate all
existing tags used in the system. For this we would need an additional table, which seems to make implementation
a lot more complex. The question is if we need an operation that lists all tags present in the system?

### Challenges

#### Extension

`hstore` is an extension, which we need to enable in PostgreSQL. It's a trusted extension, so that shouldn't be too
hard.

It also looks like AWS RDS supports `hstore`.

#### SeaORM

SeaORM supports JSONB, but not hstore. It looks like we need to implement support for this ourselves. That might also
require changes on SQLX.

Also see:

* <https://github.com/SeaQL/sea-orm/issues/279>
* <https://github.com/launchbadge/sqlx/issues/151>

I think it's worth checking out the feasibility of this. It looks like a PR would be welcomed. If things are indeed
too hard/complex, we could still go for JSONB (see below).

### Out of scope

For now, anything related to ACLs with those labels is out of scope. Any user can set labels during the creation of a
document, or can alter them later on. Also are labels not being used for ACL processing of their documents.

### Use case: location

The "location" use case could be solved by using a label like `importer=<name>`. This would be `importer=redhat-csaf`
for the preconfigured `redhat-csaf` importer.

When uploading from the browser, the user should be able to enter arbitrary labels. But those should be optional, and
it should not be a requirement, as the decision how labels are being used is up to the user.

## Alternatives

### Tags

The original proposal aimed at tags for getting the same functionality. The idea was that tags (like `source-redhat`)
would be easier to process and perform better. Labels (having keys and values, like `source=redhat`) seem more
flexible and, when testing, didn't perform much worse than plain tags when using PostgresSQL's `hstore`.

### JSONB

Instead of using `hstore`, we could also use `jsonb`. On the pro-side, SeaORM supports JSONB. The performance is
similar. However, if we don't pay attention, we might end up with more complex data in this field as `hstore` would
allow, as JSONB can store complex objects.

## Inspiration

* [^1]: <https://www.crunchydata.com/blog/tags-aand-postgres-arrays-a-purrfect-combination>: Tags and Postgres Arrays, a
  Purrrfect Combination
