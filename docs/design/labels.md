# Tags

## Rationale

We currently have a `location` (sometimes named `source`) field for things that we import. The idea behind it is to
track the "source" where the document came from to allow limiting operations based on this information. Examples could
be: delete all SBOMs where `source=ci-a`, or list and filter by `source=redhat`.

On the other side, it seems weird to force/require exactly one field for a specific purpose.

## Idea

Instead of having a single field for the location, it would be possible to add "tags" to those documents. A document
could have zero or more tags of an arbitrary string value. For example: `source-redhat`, `ci-job-a`, `team-chickens`.

Each document would have a `HashSet<String>` (or similar).

Tags could be provided by the user, or even auto-generated by the system.

### Implementation

Using PostgreSQL, it seems possible to simply use an array of strings for this approach[^1]. Performance seems fast, it
would be simple to query and easy to extend.

Although I don't think we promised a stable database at the moment, we should still be able to create a migration,
which would allow converting the existing `location` field into tags using a static pattern.

Extracting the tags would be as easy as extracting a field. IIRC SeoORM also does support that out of the box.

Selecting "by tag" also seems quite simple:

```sql
SELECT *
FROM sbom
WHERE tags @> ARRAY ['source-redhat'];
```

The only downside of this approach for our cause seems to be the fact that it isn't easily possible to evaluate all
existing tags used in the system. For this we would need an additional table, which seems to make implementation
a lot more complex. The question is if we need an operation that lists all tags present in the system?

### Use case: location

The "location" use case could be solved by using a tag pattern of `importer-<name>`. This could be
like `importer-redhat-csaf` for the preconfigured `redhat-csaf` importer.

When uploading from the browser, the user should be able to enter arbitrary tags. But those should be optional, and
it should not be a requirement, as the decision how tags are being used is up to the user.

## Alternatives

### Labels

Instead of using simple tags, it would also be possible to use "labels", having a key/value type. That could be used
to mark data as follows: `source=redhat`, `ci=job-a`, `team=chickes`.

While this might be more flexible and looks a bit simpler at first (`source=redhat` vs `source-redhat`), it also brings
more complexity.

A question would arise if the key should be unique, or if it should be possible to support multiple values per key. For
example: `team=dogs`, `team=cats`.

Also, storing this structure in the database might be less efficient and querying might be less performant due to the
nature of the data<sup>[citation needed]</sup>.

## Inspiration

* [^1]: <https://www.crunchydata.com/blog/tags-aand-postgres-arrays-a-purrfect-combination>: Tags and Postgres Arrays, a
  Purrrfect Combination
