# Labels

## Rationale

We currently have a `location` (sometimes named `source`) field for things that we import. The idea behind it is to
track the "source" where the document came from to allow limiting operations based on this information. Examples could
be: delete all SBOMs where `source=ci-a`, or list and filter by `source=redhat`.

On the other side, it seems weird to force/require exactly one field for a specific purpose.

## Idea

Instead of having a single field for the location, it would be possible to add "labels" to those documents. A document
could have zero or more labels of an arbitrary key value pairs (both strings). For
example: `source=redhat`, `ci=job-a`, `team=chickens`. Keys would be unique and have only a single value.

Each document would have a `HashMap<String, String>` (or similar structure).

Labels could be provided by the user, or even auto-generated by the system.

### Implementation

We would use a JSONB field for storing the labels. The API would ensure that we only store a single object, having only
strings as values.

Each document would get a new field called `labels` of the type `jsonb`. Using a `GIN` index, we can speed up
certain queries on the content of the field.

We can search for documents having a label of that type (by key) or for documents having a label with a specific value
(by key = value). While it might be interesting to search by arrays of values (contains) or substrings, I would not
say we start with this.

The only downside of this approach for our cause seems to be the fact that it isn't easily possible to evaluate all
existing tags used in the system. For this we would need an additional table, which seems to make implementation
a lot more complex. The question is if we need an operation that lists all tags present in the system?

### Out of scope

For now, anything related to ACLs with those labels is out of scope. Any user can set labels during the creation of a
document, or can alter them later on. Also are labels not being used for ACL processing of their documents.

### Use case: location

The "location" use case could be solved by using a label like `importer=<name>`. This would be `importer=redhat-csaf`
for the preconfigured `redhat-csaf` importer.

When uploading from the browser, the user should be able to enter arbitrary labels. But those should be optional, and
it should not be a requirement, as the decision how labels are being used is up to the user.

## Alternatives

### Tags

The original proposal aimed at tags for getting the same functionality. The idea was that tags (like `source-redhat`)
would be easier to process and perform better. Labels (having keys and values, like `source=redhat`) seem more
flexible and, when testing, didn't perform much worse than plain tags when using PostgresSQL's `hstore`.

### HStore

HStore is a PostgreSQL extension for key/value maps (of string data). It has better performance in some cases compared
to JSONB, but is equally powerful for our use case.

There are some issues though. HStore is an extension, which needs to be enabled. It is a trusted extension and available
on AWS RDS for example. So that should not be a big issue.

But also, SeaORM supports JSONB, but not hstore. It looks like we need to implement support for this ourselves. Not
only on SeaORM, but also in SQLX, which acts as the postgresql "driver".

Also see:

* <https://github.com/SeaQL/sea-orm/issues/279>
* <https://github.com/launchbadge/sqlx/issues/151>

After checking out what would be involved, it seems a bit more work than originally expected. We would require an
encoder for, but also a parser for both the binary and the string protocol. That latter includes all kinds of escape
and extra processing (like null values). I don't think that the effort is worth at this point.

## Inspiration

* [^1]: <https://www.crunchydata.com/blog/tags-aand-postgres-arrays-a-purrfect-combination>: Tags and Postgres Arrays, a
  Purrrfect Combination
